---
title: Logging with sectionctl
description: How to view logs from your Node.js apps
keywords: logging, node.js, sectionctl
---

## Viewing logs

To fetch your app’s most recent logs, use the `sectionctl logs` command:

```
sectionctl logs --app-id 1337
```

The `logs` command retrieves 100 log lines by default. You can specify the number of log lines to retrieve (up to a maximum of 1,500 lines) by using the `--lines` (or `-n`) option.

```
sectionctl logs -a 1337 -n 500
```

## Real-time tail

Similar to `tail -f`, real-time tail displays recent logs and leaves the session open for real-time logs to stream in. By viewing a live stream of logs from your app, you can gain insight into the behavior of your live application and debug current problems.

You can tail your logs using `--tail` (or `-f`).

```
sectionctl logs -a 1337 --tail
```

When you are done, press `Ctrl+C` to return to the prompt.

A real-time tail session is automatically terminated after one hour of inactivity.

## Log format

The output format of the `sectionctl logs` command is as follows:

```
timestamp source[process]: message
```

- Timestamp - The date and time recorded at the time the log line was produced by the dyno or component. The timestamp is in the format specified by [RFC5424](https://tools.ietf.org/html/rfc5424#section-6.2.3), and includes microsecond precision.
- Source - All of your app’s processes (web apps, background workers, cron) have the source `app`. All of Section’s system components (workload scheduler, workload build) have the source `section`.
- Process - The name of the process or component that wrote the log line. For example, app #2 appears as `app.2`, and the workload build process appears as `build`.
- Message - The content of the log line. Lines generated by processes that exceed 10000 bytes are split into 10000 byte chunks without extra trailing newlines. Each chunk is submitted as a separate log line.

## Filtering

If you only want to see logs with a certain source, a certain region, or both, you can use the --source (or -s) and --region (or -r) filtering arguments:

```
$ sectionctl logs
  -a, --app-id=[int]
  -r, --region=[us-west,us-east,eu-west,apac]
  -s, --source=[app,section,build]
```

If you're doing a reasonable traffic, running `sectionctl logs` without `--region` and `--source` this will output _a lot_ of logs.

## Log message ordering

When you retrieve logs, you might notice that they aren’t always in exact chronological order, especially when multiple components are involved. Logs originate from many sources and are assembled into a single log stream by Section. Log messages might be collected across multiple regions and aggregation points, and therefore be delivered out of order.

## Log history limits

Section's app logging is designed for aggregating and routing log messages, not for storage. It retains the most recent 10,000 lines of your consolidated logs, which expire after 1 week.

## Writing to your log

Anything your app writes to standard out (`stdout`) or standard error (`stderr`) is captured into your logs. This means that you can log from anywhere in your application code with a simple output statement.

To take advantage of real-time logging, you might need to disable any log buffering your application is performing.

Some frameworks send log output somewhere other than `stdout` by default. These might require extra configuration.
