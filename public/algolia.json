[{"content":"GoSquared Credentials File gosquared-visitor-count You need to add a file to the root of the repository called: gosquared-visitor-count The content of file should be: \u0026lt;threshold\u0026gt; \u0026lt;ID\u0026gt; \u0026lt;secret\u0026gt; varnish \u0026lt;hostname\u0026gt; \u0026lt;api_key\u0026gt; Where “threshold” is the max number of customer you want on your site. Where “ID” comes from end of URL when you are logged into gosquared. Where “secret” is a string with no spaces that only you know. Where \u0026ldquo;hostname\u0026rdquo; is the first hostname(domain name) used in your Section Application. Where \u0026ldquo;api_key\u0026rdquo; is an api_key for your GoSquared project provided by Section engineering team. Example: 300 GSN-000000-M a000000000bc111111111d00000 varnish www.mysite.com jkfjijfejADFD The GoSquared ID will be provided by Section engineering team.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/virtual-waiting-room/go-squared-credentials/","objectID":"f53387d78f7ca55da3474f9db8854659_0","order":0,"tags":null,"title":"Acquire GoSquared Credentials"},{"content":"Aperture is the Section management dashboard; a web user interface to manage applications, domains and all other components of a customers account. Section also provides an API API for programmatic interaction with the Section platform.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/aperture/","objectID":"b11bd8be354ec28a84d444769e8e632f_0","order":0,"tags":null,"title":"Aperture overview"},{"content":"Overview The ThreatX portal allows you to easily block an IP Address or a CIDR range by adding it to blacklist. Blacklist an IP Address/CIDR range As first step you will have to log into the ThreatX portal at x.threatx.io and access Settings \u0026gt; IWAF from the navbar. Select the Blacklist tab and click on Add Entry in the top right corner. This will present you with a pop to add the IP address or the CIDR range. Add and click Submit. If you are blacklisting an entry previously in the whitelist make sure that you remove it from the whitelist.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/threatx/blacklist-an-ip/","objectID":"4999306225d3dab95a1dd65d42bd4930_0","order":0,"tags":null,"title":"Blacklist an IP address or a CIDR range"},{"content":"Overview Optidash module allows the flexibility to control the quality of the optimized image. How To You can control the optimized image quality by changing the following settings in the advanced configuration settings for Optidash : \u0026quot;lossless\u0026quot; : \u0026quot;true/false\u0026quot; Enable disable lossy compression. \u0026quot;quality\u0026quot; : 1 - 100 This options will only be used if the LOSSY option is set to true. Can be a number in the range of 1 - 100. If the quality option is not provided it will default to \u0026ldquo;auto\u0026rdquo; where Optidash will optimize the images based on their characteristics.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/optidash/change-image-quality/","objectID":"2aebbfcc7075b0b4a937f86c5d781b2a_0","order":0,"tags":null,"title":"Change optimized image quality"},{"content":"Overview There are two ways for clearing Optidash cache. Clear the entire Cache Clear a particular image from the cache. Clear the entire Cache In the advanced configuration settings for Optidash you can change the following parameter \u0026quot;cache_version\u0026quot; : \u0026quot;v1\u0026quot; Updating the \u0026ldquo;cache_version\u0026rdquo; will clear the entire Optidash cache. Clear a particular image from the cache. To clear the cache for an individual URL you can use our API: https://aperture.section.io/api/ui/#!/Proxy/proxyStatePost with the proxyName as Optidash and the URL of the image as the banExpression. You can also clear the cache for the URL using the Section Console (formerly known as Aperture portal). This feature is an option available under Clear Cache \u0026gt; Optidash When using Optidash behind Varnish be sure to clear the Varnish cache to see the updated image.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/optidash/how-to-clear-cache/","objectID":"1b670790deeb2d9aab1747db056d12f2_0","order":0,"tags":null,"title":"Clear Optidash cache"},{"content":"Configuration When you are ready to start creating more advanced configurations for your proxies, you can start editing the configuration files directly. All of the files in your repository can be accessed by visiting Advanced Config under the Application Edge menu in the left nav of Aperture. For more information on more basic configurations done through our GUI, check out quick configuration. In the repository you can see all the files in your repository, commits to those files, stats, and a branching diagram. All of your advanced configuration for any of your reverse proxies will be done by editing the files here. Inside Advanced Config, you should see one folder for every reverse proxy running on your application and one \u0026lsquo;section.config.json\u0026rsquo; file, where you can add additional reverse proxies to your stack. If you want to add a new reverse proxy your stack, check out our guide. Working locally Because your Section configuration is a git repository, you can also clone it locally to work with as well as using the web editor. This is particularly helpful if you want to do local development with our Developer POP. Copy the URL from the Advanced Config page labelled Clone with HTTPS and use this to run git clone \u0026lt;url-from-advanced-config\u0026gt;. Git Authentication There are two ways to authenticate git: If you log into Aperture with a username \u0026amp; password you can just use those credentials to also authenticate git. If you access Aperture via SSO, or you don\u0026rsquo;t want to use your main credentials for git, you can also authenticate with an API Token. If you don\u0026rsquo;t already have an API token, follow these instructions to create one. Once that is done you can authenticate git using section-token as the username and the API Token value as the password.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/configurations-with-git/","objectID":"3717667437924dbb790dfe909dca4cb6_0","order":0,"tags":null,"title":"Configurations with GIT"},{"content":"What does it do This module is built on the Section OpenResty module and provides a more robust upstream definition by load balancing traffic using an internal consistent hash to select the right upstream node. Available hashed key values: True-Client-IP URI Path See the set up guide to implement this module into your module stack.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/consistent-hash/","objectID":"ae45d19cd361b7201c6f15e5f22bce4f_0","order":0,"tags":null,"title":"Consistent Hash"},{"content":"Overview The Virtual Waiting Room module offers an easy to use interface to control the max number of concurrent users on the site. Increase/Decrease user threshold The maximum number of concurrent users can be increased/decreased easily by using the counter under the Control Visitor Count section. This can also be controlled directly by changing the threshold value in the Advanced Configuration and the GoSquared Credentials file The default behavior is to force all users to be rechecked if you reduce the number of users allowed on your site. This may cause some users currently on the site to be put into the waiting room. If you uncheck Apply threshold to existing users? option, user\u0026rsquo;s currently on the site won\u0026rsquo;t be kicked off. It will only naturally decrease. This values always defaults to on.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/virtual-waiting-room/control-user-threshold/","objectID":"cbe27403f11fa2d03fdf45761c13223b_0","order":0,"tags":null,"title":"Control User Threshold"},{"content":"On your main account dashboard, click Create application. Enter the name of your live web site. Do not include the protocol (i.e. http or https). The system will try to automatically determine the IP of your origin. Click Next. Click Performance, then click Varnish Cache v5.2 Basic. Click Next. Enter an account name. Think of this as the organization/company that your website belongs to. (click here a more in-depth explanation of an account). Click Next. Review the confirmation screen and click Setup. Wait a moment while the system deploys your Application Edge. Click I\u0026rsquo;ll explore first. Your Application Edge is now ready for traffic. The next step is to Set Up DNS.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/going-live/create-application-edge/","objectID":"900cc021eb32c6ad870f05185005ec71_0","order":0,"tags":null,"title":"Creating an application"},{"content":"What does it do Automatically detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection. From https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP A primary goal of CSP is to mitigate and report XSS attacks. XSS attacks exploit the browser\u0026rsquo;s trust of the content received from the server. Malicious scripts are executed by the victim\u0026rsquo;s browser because the browser trusts the source of the content, even when it\u0026rsquo;s not coming from where it seems to be coming from. CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. The CSP Report module allows users to easily insert and modify security policies and track which part of a site/application has experienced policy breaches.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/csp-report/","objectID":"2ec2fc47139f2de57ceb52d7bc612425_0","order":0,"tags":null,"title":"CSP Report"},{"content":"Overview The Virtual Waiting Room module offers a convinient way to design your waiting room page. Edit the Virtual Waiting Room HTML The HTML to be displayed when the users are put in a queue can be edited under the Upload HTML section. A preview of the page after it has been uploaded is provided under the Preview HTML tab.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/virtual-waiting-room/edit-waiting-room-html/","objectID":"5f0d3b889179720514e05d2e5f23fd45_0","order":0,"tags":null,"title":"Design the Waiting Room"},{"content":"Proxy Stack Proxy Stacks are chained Proxies (or Reverse Proxies) and are composed of pre-packaged by Section Modules. These Modules are chained together to give combined functionality. A simple proxy stack Simple proxy stack A medium proxy stack Medium proxy stack A complex proxy stack Complex proxy stack","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/example-proxy-stacks/","objectID":"63a845cca96a35e414c98b6a57ee11b9_0","order":0,"tags":null,"title":"Example Proxy Stacks"},{"content":"Overview Utilize Section\u0026rsquo;s powerful logging feature to quickly track down which part of a website or application is violating Content Security Policy directives. Step 1 - Setup CSP Report module Follow the instructions from this page for more details Step 2 - Search Section logs for violations Log into your Section portal and click HTTP Logs from the left nav-bar. Replace the * in the search box with the following querie _type:openresty-access-log AND uri_path:\u0026quot;/.well-known/csp_reporting\u0026quot; Then add the field Referrer as a column. The referrer column will show you which part(s) of the web site or application is violating Content Security Policy directives. If there are a lot of violations, you can simply use Kibana\u0026rsquo;s powerful Visualize feature to find the top offenders, we recommend using a Data Table and splitting the table by the top 5 Referrers","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/csp-report/find-a-csp-violation-report/","objectID":"aeaca5c97162d9946e9cbec4f39cb3cf_0","order":0,"tags":null,"title":"Find a CSP violation report"},{"content":"Launch Tutorial","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/going-live/","objectID":"10e39392359ded20aa7dfe5e0d564ccf_0","order":0,"tags":null,"title":"Going Live"},{"content":"HTTP Logs Clicking on \u0026ldquo;HTTP Logs\u0026rdquo; in the left navigation bar opens up a view of Kibana. Kibana will allow you to search through your logs to dig deeper into trends you found in Graphite or Grafana. To open Kibana in its own window, click the “open in new window” button at the top of the Kibana frame. On the Discover view in Kibana, you can either select items from the left nav, or type searches into the search bar. Here are a fields that are useful to know: varnish_handling - will add a column and show you whether a log was a hit or a miss. varnish_handling:miss - will show all logs that were misses content_type - shows you whether the content was image, html, js, etc status - shows response code (200, 3XX, 4XX, etc) _type - will indicate if the log was for varnish, origin proxy, last proxy, etc scheme - will indicate if the request was HTTP or HTTPS You can then take these searches and turn them into different Graphs in the “Visualization” view. Then you can save these visualizations to a Dashboard to view later under the “Dashboard” view. If you want to analyze your website using Graphite, start by grouping metrics such as error rates, cache hit and miss rates and then apply functions to help smooth data points for bigger trends or show variance between individual data sets. Related Basic Logging and Search Custom Logging and Search Debugging Howtos Debugging Reference Guides","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/https-logs/","objectID":"3acbb93856aefbf9a3e917aef52e19e8_0","order":0,"tags":null,"title":"HTTP Logs"},{"content":"Modsecurity Configuration The initial configuration in a repository starts ModSecurity’s SecRuleEngine in DetectionOnly mode (this writes log entries but never executes any disruptive actions) with rules from base_rules \u0026amp; optional_rules. This is a great starting point, as you can immediately see possible threats without stopping legitimate traffic to your site. Note: Whilst many tutorials and guides use Symbolic Links to have content appear in the rules/activated_rules directory, symbolic links complicate the use of source control \u0026amp; local development. It is recommended to copy files instead, and never use symbolic links in any Section configuration. To add a new rule set, copy the rule set .conf file into your rules/activated_rules directory. To remove a rule set, delete the corresponding .conf file from your rules/activated_rules directory. To edit a rule set, edit the text content of the corresponding .conf in your rules/activated_rules directory. There is also a GUI tool under Configuration\u0026gt;Proxy in the application portal to help enable and disable rule sets. For documentation see Modsecurity and OWASP Modsecurity Rule Set Project. How ModSecurity work on Section At every opportunity, the implementation of ModSecurity on the Section platform has been designed to be as close as possible to how it would be if you had installed ModSecurity yourself locally. Section uses the official ModSecurity distributions published by [Trustwave] running upon Apache. Section does not use custom-compiled builds of modsecurity. ModSecurity will be initialized with the configuration found in the modsecurity.conf file, and matching rule files at rules/activated_rules/*.conf under the corresponding subdirectory of your Section application repository. Note: Like other proxies in Section, ModSecurity will sit between a TLS offload system accepting incoming connections, and an outbound proxy making upstream connections. Two additional HTTP request headers will be added to carry connection information, X-Forwarded-For containing the downstream client IP address and any intermediate proxy IP addresses, and also X-Forwarded-Proto which will specify either http or https depending on the protocol with which the downstream client connected. High Availability \u0026amp; ModSecurity State To achieve high availability \u0026amp; performance in production, Section will run multiple instances of your ModSecurity proxy stack. It’s important to consider that each instance is unaware of the internal state of other running instances. A set of client requests will likely be spread across different instances, and any rules that track state (using setvar, setuid, setsid, etc) will likely act differently in a distributed environment. Enabling Protection Every rule set can have false positives in new environments and any new installation should initially run with Detection only. After running ModSecurity in detection only mode for a while, review the logs and decide if any further modifications to the rule sets should be made before switching to protection mode. To enabled protection edit the modsecurity.conf file and change the setting for SecRuleEngine from DetectionOnly to On. Available versions ModSecurity 2.7 apache 2.4.7 modsecurity 2.7.7 OWASP ModSecurity Core Rule Set ([commit c63affc9dfa6294ecf8782ae4d1f1fb2c9fd5a18]) included by default","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/modsecurity/","objectID":"32d2ef14c110eb04866370ef9a29374f_0","order":0,"tags":null,"title":"ModSecurity"},{"content":"What does it do Use the power of Lua to achieve edge side rewrites and much more. Install and configure Nginx/Lua on a globally distributed Edge Compute Platform with the confidence of DevOps control. Section takes the complications out of installing and configuring the software by providing you with: A fully managed instance of the most up-to-date version. Git-backed workflows for easy version control. A development environment to test your configurations. Rewrite Body Content Out of the box, the Nginx with Lua module is easily configurable to rewrite the body of the HTML response on the fly to inject scripts, fix broken links, update CSS files, and much more. LUA is an incredibly fast script level HLL language so it is easy to work with and perfect for on-the-fly rewrites. HTML Streaming with LUA Cache the head of every document to improve your time to start render and time to first byte (TTFB) speeds, while maintaining your current code base. Complex Routing Fetch data on the fly from external storage devices to determine the optimal upstream server or origin location to which your Edge Compute Platform should pass each HTTP request.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/openresty/","objectID":"48f32cad10f44eb7c3fdd267fba09762_0","order":0,"tags":null,"title":"OpenResty"},{"content":"Optidash Module Settings Once your application has been set up with Optidash you will find the following settings under Advanced Config \u0026gt; Optidash in the Section Console (Aperture portal). { \u0026quot;api_key\u0026quot;: \u0026quot;REDACTED\u0026quot;, \u0026quot;lossless\u0026quot;: false, \u0026quot;enabled\u0026quot;: true, \u0026quot;ttl\u0026quot;: 604800, \u0026quot;cache_version\u0026quot;: \u0026quot;v1\u0026quot;, \u0026quot;s3\u0026quot;: { \u0026quot;key\u0026quot;: \u0026quot;REDACTED\u0026quot;, \u0026quot;secret\u0026quot;: \u0026quot;REDACTED\u0026quot;, \u0026quot;region\u0026quot;: \u0026quot;ap-southeast-2\u0026quot;, \u0026quot;bucket\u0026quot;: \u0026quot;section-kraken\u0026quot; } } \u0026quot;lossless\u0026quot; : \u0026quot;true/false\u0026quot; Enable disable lossy compression. \u0026quot;quality\u0026quot; : 1 - 100 This options will only be used if the LOSSY option is set to true. Can be a number in the range of 1 - 100. If the quality option is not provided it will default to \u0026ldquo;auto\u0026rdquo; where Optidash will optimize the images based on their characteristics. \u0026quot;cache_version\u0026quot; : \u0026quot;v1\u0026quot; You can update the \u0026ldquo;cache_version\u0026rdquo; to clear the entire Optidash cache. \u0026quot;ttl\u0026quot; : \u0026lt;time\u0026gt; Sets as cache-control maxage in the response headers sent downstream \u0026quot;enabled\u0026quot; : true/false You can enable/disable image optimization by changing the value for the \u0026ldquo;enabled\u0026rdquo; option. When in a disabled state the module acts as a reverse proxy. \u0026quot;s3\u0026quot; : {} Section provides storage for optimized images. If you want the optimized images to be stored in your own S3 bucket we can set it up for you. \u0026quot;optimize_paths\u0026quot; : [\u0026quot;/images/\u0026quot;, \u0026quot;/media/\u0026quot;] You can provide a list of path prefixes for which you want the Optidash module to attempt optimization. The Optidash module optimizes by default the image extensions png,jpeg,jpg,gif and webp. For any other assets you can use the above feature. For example using a prefix /images as shown above will instruct the Optidash module optimize all images which have the prefix /images in their URL. Image Resizing Section Optidash module can use querystrings to resize using the following strategies: auto, exact, fill, fit, landscape, portrait. See Optidash docs for details: https://docs.optidash.ai/operations/resizing Querystring paramaters accepted: width - positive integer height - positive integer mode - Image resizing mode, default is auto Note: legacy parameter from previous solution strategy - string indicating strategy to be used Example auto mode: www.example.com/image.png?mode=auto\u0026amp;width=100 Legacy strategy usage: www.example.com/image.png?strategy=auto\u0026amp;width=100\u0026amp;height=200 Bypass optimization Section Optidash module will not optimize an image when the request contains the header: Optidash-Optimized: false","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/optidash/optidash-advanced-config/","objectID":"4a0f16e0d96578fe9aa9eebfc782889d_0","order":0,"tags":null,"title":"Optidash Advanced Configuration"},{"content":"What does it do Secure your application from automated threats with Radware Bot Manager Radware Bot Manager specializes in non-human traffic detection and management. Their best-of-breed bot management solution secures online businesses against automated threats such as content and price scraping, account takeover, gift card fraud, skewed analytics, ad fraud, and application DoS. Radware’s Bot Manager bot detection engine utilizes multiple techniques to identify bots including proprietary Intent-based Deep Behavior Analysis (IDBA), user behavior analysis, device and browser fingerprinting, IP reputation, and machine learning. Over 250+ browser parameters are used by proprietary algorithms to build a unique fingerprint of each user. Challenge-response mechanisms such as CAPTCHA helps to build a closed-loop feedback system that dynamically improves the machine-learning models. Once a bot is detected, Radware Bot Manager can block, provide alternate content, serve a CAPTCHA challenge, or perform other custom actions. Additionally, these responses can be customized for specific sections of an application. Intent-based Deep Behavioral Analysis IDBA can detect sophisticated attacks that are either massively distributed or adequately \u0026lsquo;low and slow\u0026rsquo; to operate under the permissible limits of rule-based security measures. Ability to Handle Bot Traffic in Multiple Ways Solution allows you to take custom actions based on bot signatures/types. You can outsmart competitors using \u0026lsquo;feed fake data\u0026rsquo; method that enables you to feed fake pricing and product information to the bots deployed by competitors. Battle-Tested for Zero False Positives Processing billions of pages, and with constant learnings, Radware Bot Manager bot prevention service is tweaked to ensure that none of the genuine traffic to your website and mobile app is blocked. Transparent Reporting and Comprehensive Analytics A granular classification of different types of bots such as search engine crawlers and malicious bots allows you to efficiently manage non-human traffic. Transparency in reports is particularly useful for automated threats such as digital ad fraud. Accuracy \u0026amp; Scalability Radware Bot Manager offers unmatched accuracy without affecting user experience. Their detection engine processes billions of API calls every month and scales to suit the demands of your application. Seamless Integration with Section Radware Bot Manager can be easily deployed on the Section Edge Compute Platform without any infrastructural changes. Section and Radware Bot Manager are both highly scalable and work seamlessly to eliminate automated threats in real time.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/radware-bot-manager/","objectID":"f39331449438f9a6dd6d45524e0ca558_0","order":0,"tags":null,"title":"Radware Bot Manager"},{"content":"WHY: To understand how to improve your site, you first need a benchmark for where you are now. HOW: After you go live, wait about an hour for data to populate. While Section’s real time reporting will show data inside the first minute of go live, you should wait an hour for trends to emerge. Then use the evaluation guide above to look at your key metrics.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/performance-optimization/review-your-metrics/","objectID":"fb4198e0dadcc5912fc3514f9799acce_0","order":0,"tags":null,"title":"Review Your Metrics"},{"content":"Overview This tutorial will guide you through the process of adding the Consistent Hashing module to your proxy stack with default configuration files. This tutorial assumes you\u0026rsquo;ve cloned your application\u0026rsquo;s git repository to your local machine. Step 1 - Updating section.config.json Add the following object to your proxystack array in your section.config.json file located in the root of your repository. { \u0026quot;name\u0026quot;: \u0026quot;consistenthash\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;consistenthash:1.0.0\u0026quot; } Typically this is added downstream of the module you want to load balance traffic to based on the consistent hash. Step 2 - Adding default files Create a consistenthash directory in the root of your repository. Create the following files under the consistenthash directory: server.conf Step 3 - Populate the server.conf file The server.conf file contents: # Use HTTP 1.1 to allow for keepalive connections proxy_http_version 1.1; # Pass the request host header through to the upstream proxy_set_header Host $host; # Allow http connections to be kept open proxy_set_header Connection \u0026#39;\u0026#39;; # Pass the origin server response header through rather than allowing nginx to set it to \u0026#34;nginx\u0026#34; proxy_pass_header Server; location / { proxy_pass \u0026#34;http://consistenthash_uri_next_hop_upstream\u0026#34;; } This default config implements the consistent hash based on the URI path of the HTTP request in the proxy_pass directive, but you can use the following values for other forms of consistent hashing: consistenthash_uri_next_hop_upstream - consistent hash based on the URI path. consistenthash_client_ip_next_hop_upstream - consistent hash based on the originating Client IP address. next_hop_upstream - no consistent hashing applied. Step 4 - Deploy Commit your changes and push them to the desired branch you are working on. If you run into any issues please contact support@section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/consistent-hash/","objectID":"fe132897d9049e24de9acdc943f3526c_0","order":0,"tags":null,"title":"Set up Consistent Hash"},{"content":"Please contact a Section engineer by emailing support@section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/modsecurity/","objectID":"14b53854c1ba9fbd1064e9241c349a60_0","order":0,"tags":null,"title":"Set up Modsecurity"},{"content":"Overview This tutorial will guide you through the process to adding the Radware Bot Manager module to your proxy stack with default configuration files. This tutorial assumes you\u0026rsquo;ve cloned your application\u0026rsquo;s git repository to your local machine. Step 1 - Updating section.config.json Add the following object to your proxystack array in your section.config.json file located in the root of your repository. { \u0026quot;name\u0026quot;: \u0026quot;radwarebotmanager\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;radware-bot-manager:5.3.4\u0026quot; } You can add this module at any index in your proxystack array. We\u0026rsquo;d recommend adding this module as the first module. Step 2 - Adding default files Create a radwarebotmanager directory in the root of your repository. Create the following files under the Radware Bot Manager directory: shieldsquare.json Step 3 - Populate the shieldsquare.json file The shieldsquare.json file will have the following format : The key and deployment_number will be provided to you by Section. You can contact us at support@section.io. Step 4 - Deploy Commit your changes and push them to the desired branch you are working on. If you run into any issues please contact support@section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/radware-bot-manager/","objectID":"11a85c8d205220aafbe6ba6901a5db64_0","order":0,"tags":null,"title":"Set up Radware Bot Manager"},{"content":"Overview This tutorial will guide you through the process to adding the Signal Sciences module to your proxy stack with default configuration files. Setting up Signal Sciences when setting up an application When creating your application you will want to select the Signal Sciences on the second page of the setup process. Setting up Signal Sciences on an existing application Step 1 - Adding default files Clone the application repository by selecting the Advanced Config option in the left sidebar and copying the repo URL. Create a sigsci directory in the root of your repository. Create the following files under the Signal Sciences directory: proxy-features.json Step 2 - Populate the proxy-features.json file The proxy-features.json file will have the following format : { \u0026quot;environment_variables\u0026quot;: [ \u0026quot;SIGSCI_ACCESSKEYID=access_key\u0026quot;, \u0026quot;SIGSCI_SECRETACCESSKEY=secret_access_key\u0026quot; ] } Contact Section support at support@section.io. Our engineers will organize an account with Signal Sciences. The Section team will provide you with credentials to populate the file and access the Signal Sciences management console. Step 3 - Deploy Commit your changes and push them to the desired branch you are working on. Now, when you select the Advanced Config option in the left sidebar you will see the newly added sigsci folder under your root directory. If you run into any issues please contact support@section.io Step 4 - Update your proxy stack config file Add the following object to your proxystack array in your section.config.json file located in the root of your repository. { \u0026quot;name\u0026quot;: \u0026quot;sigsci\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;sigsci:latest\u0026quot; } You can add this module at any index in your proxystack array. We\u0026rsquo;d recommend adding this module as the first module in the proxy stack. You are now setup with Signal Sciences as part of your Section proxy stack. If you have any questions reach please contact section support at support@section.io","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/signal-sciences/","objectID":"8d09a86a12e9fd52a56d293f18700ac2_0","order":0,"tags":null,"title":"Set up Signal Sciences"},{"content":"Please contact a Section engineer by emailing support@section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/sitespect/","objectID":"b14b92eea1b0efb2f15c77ee1d748c4f_0","order":0,"tags":null,"title":"Set up Sitespect"},{"content":"Download and install sectionctl Go to GitHub to download the latest release of sectionctl for your platform. On Linux this looks like: wget https://github.com/section/sectionctl/releases/download/v1.8.0/sectionctl-v1.8.0-linux-amd64.tar.gz tar zxvf sectionctl-v1.8.0-linux-amd64.tar.gz Then place the executable on your path and ensure it\u0026rsquo;s executable. On Linux this looks like: mv sectionctl /usr/local/bin/sectionctl chmod +x /usr/local/bin/sectionctl Configure authentication To set up credentials so the CLI tool works, run: sectionctl login This will prompt you for your Section username and password, and securely store them where sectionctl can find them. The Section CLI is now configured and ready to use Next: set up an example Node.js app. Node.js Edge App Hosting is a new Section product, so it may have some rough edges. If you see something that needs improvement, we\u0026rsquo;d love to hear your feedback.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/launching-a-nodejs-app/set-up-sectionctl/","objectID":"5f3b0363d7e071ee1cd91dd27be47a3f_0","order":0,"tags":null,"title":"Set up the Section CLI tool"},{"content":"Section Developer PoP runs on Kubernetes. Minikube is a miniature, prepackaged Kubernetes cluster that works locally on a desktop Microsoft Windows, Mac or Linux computer. Minikube runs in the free and open source VirtualBox. Verify that you have installed VirtualBox Download and install Minikube v1.6.2. Version 1.6.2 is the Section supported version of Minikube. https://github.com/kubernetes/minikube/releases/tag/v1.6.2 Download and install kubectl v1.16.2. Version v1.16.2 is the Section supported version of kubectl. https://kubernetes.io/docs/tasks/tools/install-kubectl Start minikube: minikube start Initialize the Developer PoP Start Minikukbe minikube start Minikube will start as below on Ubuntu 18.04. minikube start 🙄 minikube v1.6.2 on Ubuntu 18.04 ✨ Automatically selected the 'virtualbox' driver (alternates: [none]) 💿 Downloading VM boot image ... \u0026gt; minikube-v1.5.1.iso.sha256: 65 B / 65 B [--------------] 100.00% ? p/s 0s \u0026gt; minikube-v1.5.1.iso: 143.76 MiB / 143.76 MiB [-] 100.00% 4.14 MiB p/s 35s 🔥 Creating virtualbox VM (CPUs=2, Memory=2000MB, Disk=20000MB) ... 🐳 Preparing Kubernetes v1.16.2 on Docker '18.09.9' ... 💾 Downloading kubeadm v1.16.2 💾 Downloading kubelet v1.16.2 🚜 Pulling images ... 🚀 Launching Kubernetes ... ⌛ Waiting for: apiserver 🏄 Done! kubectl is now configured to use \u0026quot;minikube\u0026quot; Initialize the Developer PoP minikube ssh \u0026quot;docker run --rm --net=host -v /var/lib/minikube:/var/lib/minikube:ro sectionio/section-init\u0026quot; Depending on the speed of your internet connection and the power of your computer, the initiation of the Developer PoP can take several minutes. Initialize Namespaces Unable to find image 'sectionio/section-init:latest' locally latest: Pulling from sectionio/section-init 96ac93103c33: Pull complete 7f806fcb5e6c: Pull complete 9f61142fa1a0: Pull complete fd79b6758639: Pull complete c99a605ef53e: Pull complete Digest: sha256:6619bbb259d0b4f20f8064385a4dad3b1529f825f76ae10867cae11d6a092332 Status: Downloaded newer image for sectionio/section-init:latest namespace \u0026quot;section-bootstrap\u0026quot; created serviceaccount \u0026quot;section-bootstrap\u0026quot; created clusterrolebinding \u0026quot;section-bootstrap-cluster-admin\u0026quot; created deployment \u0026quot;bootstrap\u0026quot; created namespace \u0026quot;section-shared\u0026quot; created service \u0026quot;developer-pop\u0026quot; created Developer PoP Ready Now your Developer PoP base is ready, but it has not yet launched any of the specific proxies in your configuration. Let\u0026rsquo;s change that by loading your Section setup into the Developer PoP. Time to Setup After each one of these terminal commands, you will need to wait a few moments for Minikube to fully launch all the Section containers. If you, for example, try and do the git pushes in the next section immediately after completing the minikube ssh command above, you may find that the git daemon or some other relevant component has not yet come online. In this case, just wait for a few minutes — the exact time depends upon the speed of your internet connection and specifications of your machine. Disable repeating messages about the kubectl component you won\u0026rsquo;t need: minikube config set WantKubectlDownloadMsg false Next, loading your Section setup into the Developer PoP","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/developer-workflow/setting-up-your-developer-pop/","objectID":"5685d63efa95b3be34b8aed8db571a55_0","order":0,"tags":null,"title":"Set-up Section Developer PoP"},{"content":"What does it do Providing real-time protection for any application, against any attack, with integrations into any DevOps toolchain. Signal Sciences was created by CISOs, CTOs, and engineers looking to integrate advanced website security with cloud solutions and DevOps workflows. Signal Sciences analyzes and blocks threats in real-time, with 95% of customers using it in blocking mode, reducing false positives while identifying more threats than other solutions. Signal Sciences uses contextual information and next-generation cloud analysis to immediately block threats while sending detailed insights to an intuitive dashboard so your development and operations teams can work together to continually improve your web application’s security. Signal Sciences integrates with tools you already use including Slack, JIRA, and Kibana so you get detailed insights where you need them, when you need them.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/signal-sciences/","objectID":"8a4bcf1ec384f14fa00f6f99069ad34c_0","order":0,"tags":null,"title":"Signal Sciences"},{"content":"What does it do SiteSpect provides the world’s only tag-free web and mobile site optimization platform, enabling online businesses to test everything and target anyone. SiteSpect gives you the power to test your ideas, discover insights, and personalize the entire customer journey. Optimize the user experience without the limitations of JavaScript tags. Typical customers see 10% RPV Lift, 10% Conversion Lift, and a 10X Revenue Benefit. The world’s leading digital companies rely on SiteSpect to help them: Deliver more relevant, compelling, and personalized content to customers across any channel. Optimize any and all functionality, including new feature releases, search algorithms, pricing and shipping, process flows (such as checkout and registration), and complete site redesigns to drive immediate actions. Generate actionable insights into customer behaviors and patterns in real time. A/B, Multivariate and End-to-End Testing Optimize the entire user experience Providing a great customer experience is important, but only if it translates into a stronger bottom line. To achieve revenue targets and mitigate risk, companies need a clear ROI. If an organization doesn’t do more than basic testing of its website and mobile capabilities, it risks impeding a consistent, omnichannel customer experience or making only marginal improvements. SiteSpect provides the personalization, optimization, and insights to drive revenue, reduce costs, and mitigate risk at the scale today’s digital businesses need. SiteSpect is leading the advancement of customer experience optimization solutions for the world’s most successful digital businesses. Only the SiteSpect patented solutions enable customers to optimize the entire user experience from the front-end (client-side) to the back-end (server-side) while centrally managing across channels, business units, and product lines. SiteSpect’s unique technology sits in the flow of your digital traffic for full visibility of requests and responses allowing for real time business impact. To see how SiteSpect can help your team optimize your web and mobile experiences, visit the SiteSpect Documentation.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/sitespect/","objectID":"b381b31fd0d02e5d3116a90c831bb678_0","order":0,"tags":null,"title":"SiteSpect"},{"content":"What does it do ThreatX is a reverse proxy that inspects and adapts to web site attacks that can infiltrate your web site and cause problems for your business. Because ThreatX doesn\u0026rsquo;t simply rely upon statically defined rule sets like old WAFs (and CDNs based on those old WAFs) you can expect a higher degree of security. This also means that there\u0026rsquo;s a lower cost to maintain that level of security, because the adaptive nature of the platform means that you don\u0026rsquo;t need to spend time and money on in-house security experts to keep your rules up to date. Of course, you can still rely on ThreatX for virtual patching, which is one of the most sought after features in a WAF. Other things to note Naturally, you can see ThreatX is on your site by looking at the Overview page in Aperture, Section management console. The Section platform writes a log for each HTTP request that passes through ThreatX. These will be available in our powerful Kibana interface alongside logs from all of the other proxies in your stack.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/threat-x/","objectID":"8491e3e5a0cf8c3b35de0434975ef08e_0","order":0,"tags":null,"title":"ThreatX"},{"content":"Overview The modular nature of the Section platform allows you to easily turn the module on or off. When in a disabled state the module acts as a reverse proxy. Toggle Virtual Waiting Room The Virtual Waiting Room can easily be turned on and off using the toggle provided under the Control Visitor Count section. This can also be controlled directly from the Advanced Configuration.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/virtual-waiting-room/toggle-virtual-waiting-room/","objectID":"9764cd7013eaef8f179190d2080ac805_0","order":0,"tags":null,"title":"Toggle Virtual Waiting Room Module"},{"content":"Whenever a request reaches a Varnish Cache instance, one of four outcomes occurs: hit, miss, pass, or synth. A key metric when evaluating website performance is cache hit rate. Cache hit rate is a measure of how effectively the cache is responding to customer requests. A hit means that the cache responded to the request with a cached resource. A miss means that the cache tried to respond to the request with a cached resource but could not do so because it did not have a copy of the requested resource in its memory. A pass means that the cache did not even try to look up a response for the requested resource — often users specifically instruct Varnish Cache to pass on urls that should never be served from cache like /checkout, but there are other causes as well. From a performance standpoint, the goal is to increase Hit % and decrease Miss and Pass %. Why do you care?: Whenever the cache answers a customer request, that means the request did not need to be answered by your website origin server. Having a large percentage of cache hits results in performance benefits and reduced costs. From a performance standpoint, Varnish Cache\u0026rsquo;s quick lookup and response time combined with the geographic distribution of Section\u0026rsquo;s platform means that your users are quickly served a response from a server close to their geographical location. This improves time-to-first-byte and keeps latency low. From a cost-savings perspective, every request that receives a response from cache does not need to connect to your origin server, greatly reducing load. With a finely-tuned caching configuration, your origin only needs to respond to requests for personalized actions such as checkout and and account pages. How do you see it?: This is the first chart we show you on the Section dashboard. To see this in action on our demo bootcamp application, go to Section Bootcamp Overview dashboard. For more detailed information, such as the absolute number of requests and size of those requests, you can view Trending Metrics. For more in-depth guidance on using our Monitoring tools, see the monitoring section of our documentation.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/performance/understand-if-your-varnish-cache-is-effective/","objectID":"ff46e2b4be6ac9aaeee2ef43327440eb_0","order":0,"tags":null,"title":"Understanding Cache Effectiveness"},{"content":"Virtual Waiting Module Settings Once your application has been set up with Virtual Waiting Room you will find the following files under Advanced Config \u0026gt; virtualwaitingroom in the Aperture portal. virtualwaitingroom.json virtualwaitingroom.json will contain the configuration of your virtual waiting room and should have the following data. The settings are as follows : \u0026quot;api_key\u0026quot; : \u0026quot;\u0026lt;YourGoSquaredAPIKey\u0026gt;\u0026quot; This will be provided by the Sectin support team. \u0026quot;threshold\u0026quot; : 1000 Threshold is the max number of concurrent customers you want on your site. \u0026quot;enabled\u0026quot; : true/false You can enable/disable image optimization by changing the value for the \u0026ldquo;enabled\u0026rdquo; option. When in a disabled state the module acts as a reverse proxy. \u0026quot;section_visitors_version\u0026quot; : \u0026quot;1\u0026quot; Updating this value will force the user to go through the virtual waiting room check even if they are active on the site. This can be useful for forcing active traffic off the site in times of extreme load. \u0026quot;hostname\u0026quot; : \u0026quot;\u0026lt;YourHostname\u0026gt;\u0026quot; This is the first hostname(domain name) used in your Section Application. waiting-room.html waiting-room.html will contain the HTML to be displayed in case the number of concurrent users on the site is more than the threshold set by you. Any CSS required to style the page should be included in this HTML file itself. Any images you wish to serve should be stored off domain (for e.g. in an S3 bucket) and then linked.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/virtual-waiting-room/virtual-waiting-room-advanced-configuration/","objectID":"a4f497cd0d5944ddf96c556f51371ac6_0","order":0,"tags":null,"title":"Using Virtual Waiting Room Advanced Configuration"},{"content":"What does it do Section implements a pure and unchanged version of the Varnish Cache. At every opportunity, the implementation of Varnish Cache on the Section platform has been designed to be as close as possible to how it would be if you had installed Varnish Cache yourself locally. Section uses the official Varnish Cache distributions published by Varnish Cache. Section does not use custom-compiled builds of Varnish Cache. Varnish Cache is started, listening on port 80. Varnish Cache VCL can found in the default.vcl file in the corresponding subdirectory of your Section application repository. Assuming Varnish Cache is the first proxy in your proxy stack, Varnish Cache will receive connections from the Section TLS Offload Proxy with two additional HTTP request headers. X-Forwarded-For containing the downstream client IP address and any intermediate proxy IP addresses. X-Forwarded-Proto which will specify either HTTP or HTTPS depending on the protocol with which the downstream client connected. Issuing cache invalidation requests to Varnish Cache sends a ban command to the Varnish Cache management interface. Section accepts any valid Ban expression and passes it to Varnish Cache unaltered. We also provide some convenience tools to help with removing particular URL\u0026rsquo;s from the cache, see our Cache Clearing documentation for more details. Requesting the Varnish Cache Log executes varnishlog for each Varnish Cache instance and returns the results. varnishncsa is also running, logging request and response details, including cache effectiveness. This data is used to drive the charts seen in Aperture. Fundamentals Varnish Cache is a HTTP caching reverse proxy. \u0026ldquo;Varnish Cache decides whether it can store the content or not based on the response it gets back from the backend\u0026rdquo;. the origin or backend can instruct Varnish Cache to cache the content with the HTTP response header Cache-Control. Varnish Cache by default does not cache cookies or other sensitive client side content. Varnish Cache has a conservative approach to caching to avoid the cache leaking sensitive data i.e. shopping cart or personalization information. Varnish Cache policies can be changed by Varnish Configuration Language (VCL). VCL is a flexible and power language that can handle a wide range of use cases. delivery from cache is usually in milliseconds. Varnish Cache is highly performant, is usually twice as fast as a backend server and Varnish Cache is usually constrained by networks. Source: Varnish 6.3 Official Docs - Starting Varnish Varnish Cache Basics The Varnish Configuration Language (VCL) is a domain-specific language for caching HTTP requests. The language is specific to the domain of caching HTTP requests and responses. Varnish Configuration Language (VCL) implements a state machine. Varnish Cache uses VCL (Varnish Configuration Language) to run as a ‘state machine’. Various Varnish Cache states are thought of, and implemented as subroutines. Varnish Cache includes built-in subroutines via builtin.vcl. VCL has functions, legal return actions and variables. VCL functions can be extended by vmods (Varnish Cache modifications). Varnish Cache on Section has a preinstalled set of vmods. Each URL in the cache is hashed and accessible via a hash key based on host-headers, IP or other criteria via VCL logic or VMODs. Varnish Cache Receive and Respond The two most important Varnish states or subroutines or subs are \u0026ldquo;received request\u0026rdquo;vcl_recv and \u0026ldquo;backend response\u0026rdquo; vcl_backend_response. \u0026ldquo;received request\u0026rdquo; vcl_recv \u0026ldquo;backend response\u0026rdquo; vcl_backend_response Varnish Cache Flow Source: Varnish Software Book Varnish Cache Flow Described Each HTTP request flows by switching between Varnish Cache states such as recv, hit, miss or pass by calling return functions which use VCL logic to determine which state is next. For each state recv there is a VCL subroutine vcl_recv. State Subroutine Name Description recv vcl_recv Received HTTP request is completely received, parsed and can then be inspected and modified by this routine. vcl_recv subroutine is terminated by calling return() and can fail, synth, restart, pass, pipe, hash, purge and vcl(label). hash vcl_hash Hash Creates a unique hash key for each cached object. By default, the builtin vcl_hash uses hostname or IP address and adds the requested URL to the cache hash. vcl_hash always runs the lookup action on the hash key and determines the next state / sub-routine i.e. hit, miss, pass or purge etc. hit vcl_hit Hit Called by vcl_hash via the lookup operation, vcl_hit finds or \u0026ldquo;hits\u0026rdquo; a cache object. High hit rates are optimal for website performance. miss vcl_miss Miss If a requested object is not found by a lookup of the cache hash key, it is declared a miss by the vcl_miss subroutine. vcl_miss decides if a document should be retrieved from a backend by returning fetch. pass vcl_pass Pass \u0026ldquo;Called upon entering pass mode. In this mode, the request is passed on to the backend, and the backend\u0026rsquo;s response is passed on to the client, but is not entered into the cache. Subsequent requests submitted over the same client connection are handled normally\u0026rdquo;. pipe vcl_pipe Pipe Pipes a HTTP request direct to backend or origin, passing back and forwards with no other VCL running. Basically turns Varnish into a dump TCP/IP proxy. fetch vcl_backend_fetch Backend Fetch vcl_backend_fetch can be called from vcl_miss or vcl_pass. It typically alters the request before it gets to the backend or origin. response vcl_backend_response Backend Response vcl_backend_response is designed to avoid caching cookies and other probably undesired data. Called after response headers are retrieved from the backend/origin. Returns vcl_deliver. deliver vcl_deliver Deliver Usually the last exit point for HTTP request flows and is often used to add or remove debug-headers. Cached content is ready to be delivered to client of user. synth vcl_synth Synth vcl_synth is called to deliver a synthetic object, generated in VCL and not fetched from the backend. Varnish Cache Modifications Varnish Cache modifications or vmods pre-installed on Section. This is a collection of modules (\u0026ldquo;vmods\u0026rdquo;) extending Varnish VCL used for describing HTTP request/response policies with additional capabilities. VMOD Name Description cookie Cookie HTTP request is received and can then be inspected and modified by this routine. vsthrottle Throttling VMOD A Varnish Cache vmod for rate-limiting traffic on a single Varnish Cache","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/varnish-cache/","objectID":"ae808a5ca0b456df64ba5a95206fd169_0","order":0,"tags":null,"title":"Varnish Cache"},{"content":"server. Offers a simple interface for throttling traffic on a per-key basis to a specific request rate. header Header VMOD for Varnish Cache Varnish Cahce Module for manipulation of duplicated HTTP headers, for instance multiple Set-Cookie headers. saintmode Saint mode backend director Saintmode lets you deal with a backend that is failing in random ways for specific requests. It maintains a blacklist per backend, marking the backend as sick for specific objects. When the number of objects marked as sick for a backend reaches a set threshold, the backend is considered sick for all requests. Each blacklisted object carries a TTL, which denotes the time it will stay blacklisted. softpurge Softpurge Softpurge is cache invalidation in Varnish that reduces TTL but keeps the grace value of a resource. It is not safe to use with Varnish Cache 5.0 onwards, use vmod-purge from Varnish Cache 5.2 instead. tcp TCP vmod The TCP vmod opens for access and modification of client TCP connection attributes from VCL. var var This VMOD implements basic variable support in VCL. xkey xkey - Surrogate keys support for Varnish Cache This vmod adds secondary hashes to objects, allowing fast purging on all objects with this hash key. bodyaccess Body access Undocumented VMOD giving access to body objects. Builtin VCL The built-in standard Varnish builtin.vcl \u0026ldquo;Make sure you understand this: Your own VCL-configuration will not overwrite this builtin configuration, it will just be prepended to each sub. Unless your VCL code executes a terminating statement (e.g. return(pass)) it will continue into these default subs.\u0026rdquo; Source: Varnish Examples Varnish Cache Resources Varnish Software Book: Intro Varnish Blog Varnish Latest Official Docs Varnish Source Code Varnish modifications This document is inspired by Integralist Available versions Varnish Cache v6.0 Varnish Cache 6.0.0 Std VMOD - https://www.varnish-cache.org/docs/6.0/reference/vmod_std.generated.html Cookie, Header, Softpurge, Var, and Xkey VMODs - https://github.com/varnish/varnish-modules#readme Varnish Cache v5.2 Varnish Cache 5.2.1 Std VMOD - https://www.varnish-cache.org/docs/5.2/reference/vmod_std.generated.html Cookie, Header, Softpurge, Var, and Xkey VMODs - https://github.com/varnish/varnish-modules#readme UUID VMOD - https://github.com/Sharecare/libvmod-uuid#readme Varnish Cache v5.1 Varnish Cache 5.1.3 Std VMOD - https://www.varnish-cache.org/docs/5.1/reference/vmod_std.generated.html Cookie, Header, Softpurge, Var, and Xkey VMODs - https://github.com/varnish/varnish-modules#readme UUID VMOD - https://github.com/Sharecare/libvmod-uuid#readme Varnish Cache v4.1 Varnish Cache 4.1 is available if you need this version Varnish Cache 4.1.9 Std VMOD - https://www.varnish-cache.org/docs/4.1/reference/vmod_std.generated.html Cookie, Header, Softpurge, Var, and Xkey VMODs - https://github.com/varnish/varnish-modules#readme UUID VMOD - https://github.com/Sharecare/libvmod-uuid#readme Varnish Cache v4.0 Varnish Cache 4.0 is available if you need this version Varnish Cache 4.0.3 Std VMOD - https://www.varnish-cache.org/docs/4.0/reference/vmod_std.generated.html Cookie VMOD - https://www.varnish-cache.org/vmod/cookie Maxmind GeoIP VMOD - https://www.varnish-cache.org/vmod/maxmind-geoip Header VMOD - https://www.varnish-cache.org/vmod/header-manipulation UUID VMOD - https://github.com/Sharecare/libvmod-uuid#readme Varnish Cache v3 If you have a need to run Varnish Cache 3, eg. you have existing v3 VCL you want to run in Section, pick this one. This proxy also has ESI enabled to support the [Magento Turpentine extension] Varnish Cache 3.0.5 Cookie VMOD - https://www.varnish-cache.org/vmod/cookie Maxmind GeoIP VMOD - https://www.varnish-cache.org/vmod/maxmind-geoip Header VMOD - https://www.varnish-cache.org/vmod/header-manipulation Varnish is a registered trademark of Varnish Software AB and its affiliates Table of contents","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/varnish-cache/","objectID":"ae808a5ca0b456df64ba5a95206fd169_1","order":1,"tags":null,"title":"Varnish Cache"},{"content":"What does it do Maintain control of user experience on your website even during periods of extreme traffic. Don’t let excess traffic volumes destroy every user’s experience When an unexpected peak traffic event occurs on your website, Section’s Edge Compute Platform can route a nominated portion of users to a Virtual Waiting Room where they can remain while other users successfully navigate, engage with and transact with your website. Optimal User Experience By placing excess users into the Virtual Waiting Room, the users who are on your website can continue to navigate, search, engage and transact with your website. Instead of all users suffering delays and outages, the users who are on your site can continue to have a top quality experience. The Waiting Room You can set and manage the threshold over which excess users will be routed to the Virtual Waiting Room. When users on the website complete their transaction or leave the website, waiting room users will be allowed back onto the website. Faster Websites Always Combine your Virtual Waiting Room with image and full page caching on Section to effectively and efficiently serve the maximum possible number of users at all times with the lowest hosting costs. Easy to Set up To use Virtual Waiting Room on Section you will be set up with a GoSquared account and the Virtual Waiting Room module on the Section platform. GoSquared provides analytics so you know how many users are on your website in real time. Section’s Virtual Waiting Room will use the real-time analytics from GoSquared to determine the number of users currently on your website. An easy to use interface is provided to control the number of concurrent users on the site. The application then displays the overload page when your maximum number of users has been reached. To add a Virtual Waiting Room to your Section application, check out the instructions.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/virtual-waiting-room/","objectID":"1cd7d3b1499f67668fde8840dd3bfab0_0","order":0,"tags":null,"title":"Virtual Waiting Room"},{"content":"Overview By whitelisting an IP address or a CIDR range you can instruct Threat-X to not inspect requests from those IPs. The ThreatX portal allows you to easily whitelist an IP Address or a CIDR range. Whitelist an IP Address/CIDR range As first step you will have to log into the ThreatX portal at x.threatx.io and access Settings \u0026gt; IWAF from the navbar. Select the Whitelist tab and click on Add Entry in the top right corner. This will present you with a pop to add the IP address or the CIDR range. Add and click Submit. If you are whitelisting an entry previously in the blacklist make sure that you remove it from the blacklist.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/threatx/whitelist-an-ip/","objectID":"3c90c4f91a331b9aa7860d6ea54bf844_0","order":0,"tags":null,"title":"Whitelist an IP Address or a CIDR Range"},{"content":"The Section platform provides superior application performance, availability, scalability, and security by putting architects, developers, and sysadmins in the driver\u0026rsquo;s seat. Unlike legacy CDN\u0026rsquo;s, Section has designed an Application Edge system for modern agile development. Section differs from contemporary CDN platforms by: allowing a choice of reverse proxy technology. allowing engineers to use normal tooling to configure the system. providing a real time devops toolset. Unlike with legacy CDNs, with Section: there is no \u0026ldquo;one size fits all\u0026rdquo;. Legacy CDNs have a single architecture that may or may not suit your needs now and into the future. there is no \u0026ldquo;push and pray\u0026rdquo;. With full integration into the development lifecycle, the Section platform allows you to test new proxy configurations on your laptop before go-live with our Developer PoP. there is no \u0026ldquo;visibility gap\u0026rdquo;. Legacy CDNs are slow to deliver diagnostics, and offer no analytics tools to turn raw data into actionable insight. We provide dynamic and detailed logs of how your traffic is passing through our system. Section is ready to handle your workload regardless of the number of sites you have or the size of your traffic. Find out about how Section is Agency Ready to help you manage multiple sites.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/better-than-a-cdn/","objectID":"2eb07e2c7571f29f8370edb6e369dcf3_0","order":0,"tags":null,"title":"Better than a CDN"},{"content":"This is a guide for setting up a new environment within an existing Section application. 1) Log Into Aperture 2) Click on the Application in which you want the new environment The number of options that appear here will vary depending on the number of applications associated with your account. 3) Click on the Create Environment button 4) Fill in New Environment Name This environment name becomes the name of a git branch within your application repository for the new environment\u0026rsquo;s config. For a thorough explanation of how Section applications and environments use git, see our overview. 5) Fill in Hostname Although Section supports many domains on a single environment, creating a new environment only requires one. If you want to associate your new environment with multiple domains, you can do so once the environment is up and running.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/create-a-new-environment/","objectID":"34df2370d10f52ee2968c84f522ea2c5_0","order":0,"tags":null,"title":"Create a New Environment"},{"content":"Introduction Section allows you to create API Tokens that belongs to your user. API Tokens will have the same permissions as your user has at the time of creation. When your user is deleted, this key will persist. Creating an API Token Go to the User Setting page by clicking on your profile picture in the top right then select API Tokens: Enter a description for what this API Token will be used for, and then click the Add button: Copy the token value and store it somewhere securely. As the warning says, this value cannot be retrieved later. If you loose this value you will need to create a new token and delete the old one. The API Tokens you have created will be listed on this page. They can be deleted by clicking the X button next to the Token description.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/api-keys/creating-an-api-key/","objectID":"258198e5dcffa6aeaa78890b6134e2d4_0","order":0,"tags":null,"title":"Creating an API Key"},{"content":"Your website has several different types of content that can be cached: HTML, Images, CSS, and JS are the main file types for consideration. HTML is the set of instructions required to load the page. Images are any images or icons you load. CSS is the style instruction for how to load images, text, and content on the page. JS is small scripts your browser will run when it is instructed to by the HTML. You can view your hit rates, volume of requests, and time to serve for each of these different content types. Why is it important? Understanding which types are being requested the most, require the most time to serve, and are being cached most frequently helps you understand where your quick wins are to get started optimizing your cache configurations. Most of the time, images and CSS will be the easiest place to boost cache rate. HTML, on the other hand, can be more difficult to cache successfully but often provides the largest performance and scalability wins as the hit rate increases. How do I see my wins? Real-Time There are two dashboards in Grafana under Real Time \u0026gt; Monitoring to understand content type caching. Grafana or Graphite The request performance dashboard shows throughput and time to serve by status on the Analysing Request Performance Grafana. The asset cache hit rates dashboard shows the hit rate by content type on the Cache Hit Rates by Asset Type Grafana.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/performance/discover-your-quick-cache-wins/","objectID":"3aa11cb3fa29b6f0f219829578385d16_0","order":0,"tags":null,"title":"Discover your quick Cache Wins"},{"content":"1. Clone application\u0026rsquo;s git repository Clone your application\u0026rsquo;s git repository located in the Advanced Config menu in the Section portal. URL from GIT repo Clone with git clone \u0026lt;url-from-advanced-config\u0026gt; 2. Add the Dev PoP remote to your repository Open the Dev Pop UI: minikube service -n section-shared developer-pop Section app ready to connect to Aperture Connect Aperture Connect to Aperture button Grant Access The application section.io-Developer-PoP is requesting access to your Section accounts. Upon approval, your browser will be redirected to the following URL with an access token appended: http://192.168.99.102:32080/app/aperture-connected.html Allow access? Grant Access Operations Click on the Operations tab. Operations Add Dev PoP Remote to Local Application Repository Enter the git commands you see here inside the repository you cloned down in Step 1. cd www.site.com git remote add developer-pop http://\u0026lt;IP-From-Operations-Tab\u0026gt;:30090/www.site.com.git Replace www.site.com with your domain which is visible in the Section portal. It won\u0026rsquo;t actually break anything if you leave it as \u0026ldquo;site\u0026rdquo;. 3. Push your configuration files to the Developer PoP Once you have added the git remote you can push to the Dev PoP by running: git push developer-pop git push developer-pop Counting objects: 176, done. Delta compression using up to 4 threads. Compressing objects: 100% (132/132), done. Writing objects: 100% (176/176), 306.64 KiB | 38.33 MiB/s, done. Total 176 (delta 37), reused 176 (delta 37) remote: Resolving deltas: 100% (37/37), done. remote: remote: varnish image not found, pulling from repository remote: modsecurity image not found, pulling from repository remote: Pulling required proxy images, please try again shortly To http://192.168.99.101:30090/www.site.com.git ! [remote rejected] Production -\u0026gt; Production (pre-receive hook declined) error: failed to push some refs to 'http://192.168.99.101:30090/www.site.com.git' If you get this message \u0026ldquo;Pulling required proxy images, please try again shortly\u0026rdquo;, that means that your machine does not have the proxy images locally and has begun downloading them. Your terminal will look as though it has exited the process and nothing is happening, but the downloads are going on behind the scenes. Try git push developer-pop every few minutes until the downloads are complete and the push goes through. The length of this process will depend entirely on the speed of your internet connection and the power of your computer. ➜ bootcamp.section.io git:(Production) git push developer-pop Counting objects: 176, done. Delta compression using up to 4 threads. Compressing objects: 100% (132/132), done. Writing objects: 100% (176/176), 306.64 KiB | 61.33 MiB/s, done. Total 176 (delta 37), reused 176 (delta 37) remote: Resolving deltas: 100% (37/37), done. remote: Validating configuration for proxy varnish... remote: Validating configuration for proxy modsecurity... To http://192.168.99.101:30090/www.site.com.git * [new branch] Production -\u0026gt; Production Services in Dev PoP Expand Services Expanded Dev PoP 4. Configure origin server details Now that your configurations are running on the Dev Pop, you will need to configure your origin server details to tell the Dev Pop where to pass the HTTP request. Use the Dev Pop UI\u0026rsquo;s Services tab where you will find information about the repository you just pushed up. A page refresh might be needed. (a) Connect Dev PoP to Aperture Make sure to connect your Dev PoP to your Aperture account and import the Environment configurations. Click on Import under the Operations column in the Services tab. Select the Environment you want to test. i.e Production Click on Import to finish importing the configurations. Import ENV To Import an Application and its Environments you must be invited as a User for that Account. This is done via Aperture: Account \u0026gt; Manage Users \u0026gt; Invite User. (b) Configure the service manually In the Operations column of the table, there will be a button for you to \u0026ldquo;Configure\u0026rdquo; that service. Do this if you do not have a Section account. It will bring up a modal asking for the following information: Hosted Name: This is the host headers for your application (e.g. www.example.com). Origin Address: This is the either a domain name or IP address that points directly to your load balancer or webserver. Origin Host Header: This is the host header the egress will use to send upstream (typically it\u0026rsquo;s the same as your hosted name). Now, you\u0026rsquo;re all set. Let\u0026rsquo;s see your new Developer PoP in action..","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/developer-workflow/loading-your-setup-into-the-developer-pop/","objectID":"c2e007ed692e5e441ed4f3292641307d_0","order":0,"tags":null,"title":"Load Setup Into Developer PoP"},{"content":"Next, we\u0026rsquo;re going to set up a NuxtJS app for you to deploy to Section\u0026rsquo;s Edge App Hosting. Setup First, let’s make sure that your local development workspace is ready. If you don’t have Node.js installed, install it from here. You’ll need Node.js version 10.14 or later. You’ll be using your own text editor and terminal app for this tutorial. If you are on Windows, we recommend downloading Git for Windows and use Git Bash that comes with it, which supports the UNIX-specific commands in this tutorial. Set up a demo app To set up a demo app, open your terminal, cd into the directory you’d like to create the app in, and run the following command: git clone https://github.com/section/nodejs-example Run the development server You now have a new directory called nodejs-example. Let’s cd into it: cd nodejs-example Pull down the dependencies and build your app by running: npm install npm run-script build The Section platform expects you have run both of these commands before you can deploy your app. You must use npm as yarn is unsupported for now. Then, run the following command: npm run-script start This starts your app’s development server on port 8080. Let’s check to see if it’s working. Open http://localhost:8080 from your browser. Your app is now ready to deploy Next: deploy your Node.js app. Node.js Edge App Hosting is a new Section product, so it may have some rough edges. If you see something that needs improvement, we\u0026rsquo;d love to hear your feedback.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/launching-a-nodejs-app/set-up-an-example-nodejs-app/","objectID":"e2b5612dff18cadea2caa61d5948d833_0","order":0,"tags":null,"title":"Set up an example Node.js app"},{"content":"Table of contents Please contact a Section engineer by emailing support@section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/cloudinary/","objectID":"07f3d369e066fc18adadac73df737991_0","order":0,"tags":null,"title":"Set up Cloudinary"},{"content":"To get your users to connect to Section servers you need to make updates to DNS. This DNS change will point the traffic to Section servers. This tutorial works with a domain name that contains a prefix, like the www. prefix in www.section.io. If you are working with a site that doesn\u0026rsquo;t have a prefix please look at bare domain support with Section. Set up the CNAME record In the management console, click DNS in the left hand menu. Copy the target CNAME record provided by Section. Go to your DNS Hosting Provider\u0026rsquo;s configuration page and replace your existing CNAME record with the one from the previous step. If there is an AAAA IPv6 record setup for the domain, it will need to be removed as Section platform uses IPv4. Back in the management console, click Verify. You\u0026rsquo;ll see a message that your DNS is correctly configured. If you have any trouble, consider looking at our HTTPS Troubleshooting guides. Let\u0026rsquo;s proceed to step 3, Enabling Automatic SSL","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/going-live/set-up-dns/","objectID":"ebff91a6247c1bceafd8e5811fd51cf3_0","order":0,"tags":null,"title":"Set up DNS"},{"content":"WHY: Before you make any changes to your cache configuration, we recommend you test them locally first. In order to test, you need to setup your local environment. HOW: To test configuration changes locally, visit our Developer PoP tutorial. Many customers also choose to integrate a staging site with the Section platform as a part of their developer workflow. If you do not want to do this step, you can skip it and make your changes live on production.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/performance-optimization/setup-your-local-environment/","objectID":"955ebeae7a37f3a6577244f6273cf69c_0","order":0,"tags":null,"title":"Setup your Local Environment"},{"content":"Section Engineering Support Section offers 24x7 support for all customer issues via email, web and chat. Contacting Support In order for our Customer Engineering team to best support your incident please provide a detailed overview of your issue, the affected environment and the overall priority level.For urgent issues email our support team. Email Support: support@section.io Web Support: Login (or create an account) to submit your request via our web form - https://support.section.io/ Chat Support: From our website (www.section.io) click the Chat icon on the lower right hand corner of the page Self-Help Support Find your answer by accessing our self-help pages: Docs: https://www.section.io/docs/ Community: https://community.section.io/ ChangeLog: https://www.section.io/changelog/ Status Page Incident information (outages, lack of functionality, etc.) is always published as quickly as possible on our status page: https://status.section.io/You can subscribe to status page updates by clicking on Subscribe to Updates.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/additional-information/support/","objectID":"9ee260c4f29398db230763e49ce7d078_0","order":0,"tags":null,"title":"Support"},{"content":"Using an API Token Use your API Token by adding it to your requests in the Section-Token header. curl -H \u0026#34;Section-Token: YOUR-API-TOKEN-HERE\u0026#34; https://aperture.section.io/api/v1 API Tokens can also be used to authenticate git when accessing the Section config repository for your application. When git prompts for your username, enter section-token, and use the API Token value as the password.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/api-keys/using-an-api-key/","objectID":"370cd802e82c5b8f8b65a6fa688bf708_0","order":0,"tags":null,"title":"Using an API Key"},{"content":"Section is built to streamline the process of managing groups of websites. If you work at an agency, you\u0026rsquo;re familiar with the unique challenges that come with overseeing large groups of sites. You want to be able to: log in with one user account for yourself and see all your client sites. give separate logins to individual clients so that they can see only their data and not that of your other clients. bill your customers independently, so that you don\u0026rsquo;t have to think about how much to charge each client. Section\u0026rsquo;s account structure is set up to do just that. Additionally, the Section platform allows you to apply a single proxy configuration to groups of sites at once and update them all with the click of a button. Each site that runs on Section Application Edge runs on a Global Network.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/agency-ready/","objectID":"7924d0329479665be48dc3172304157b_0","order":0,"tags":null,"title":"Agency Ready"},{"content":"From a terminal Run dig +trace www.yourdomain.com. If you are unable to run this command locally, leverage an online tool such as Kloth. Click to expand an example $ dig +trace www.example.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.0-P5 \u0026lt;\u0026lt;\u0026gt;\u0026gt; +trace www.example.com ;; global options: +cmd . 488165 IN NS f.root-servers.net. . 488165 IN NS g.root-servers.net. . 488165 IN NS h.root-servers.net. . 488165 IN NS i.root-servers.net. . 488165 IN NS j.root-servers.net. . 488165 IN NS k.root-servers.net. . 488165 IN NS l.root-servers.net. . 488165 IN NS m.root-servers.net. . 488165 IN NS a.root-servers.net. . 488165 IN NS b.root-servers.net. . 488165 IN NS c.root-servers.net. . 488165 IN NS d.root-servers.net. . 488165 IN NS e.root-servers.net. . 488165 IN RRSIG NS 8 0 518400 20171018050000 20171005040000 46809 . Gqx4rurS7g34OaTMZuVqeULR0YKkHJSDbeq6MhUrf2Zs9k4S+EfYYTun 9qcns+xkDlrHkcrPYMQpOjRTLHXasaZnWcnr+t2ok7MlGefnLT8OCZBh UDcDw0gO/0V4oPn6R9dkTA7l2ZOaQl5UdHh1E6GRynr5JDaqZp5R0iX3 PZaaR9oL9GxvTW5cED4C5auIVt4TCOLSuaeotMyuuNKlVUXZkAXGHKtz Nqpzj0cm+NWMATzqOHT1yJzh9BoB1POZdMNIhsksyyX3idDu4VAQIrwR zeQdHPIZhrJ4Hc+7JVEkLC6tXI56GVb+eBlFY1Q6q0M1zWi7+DjcGJJU fjsVzA== ;; Received 1097 bytes from 75.75.75.75#53(75.75.75.75) in 17 ms com. 172800 IN NS a.gtld-servers.net. com. 172800 IN NS b.gtld-servers.net. com. 172800 IN NS c.gtld-servers.net. com. 172800 IN NS d.gtld-servers.net. com. 172800 IN NS e.gtld-servers.net. com. 172800 IN NS f.gtld-servers.net. com. 172800 IN NS g.gtld-servers.net. com. 172800 IN NS h.gtld-servers.net. com. 172800 IN NS i.gtld-servers.net. com. 172800 IN NS j.gtld-servers.net. com. 172800 IN NS k.gtld-servers.net. com. 172800 IN NS l.gtld-servers.net. com. 172800 IN NS m.gtld-servers.net. com. 86400 IN DS 30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766 com. 86400 IN RRSIG DS 8 1 86400 20171018170000 20171005160000 46809 . H3HKSPmogdfIznmPZO9Qjo33Kk2kxds6Qc79ti2DcBhqfnKWLcdrlYIO hh4lXFlGQZc8ySrfXg2BZ0n1YKqea9HrktCHQsdEhJywZM/avD7EfMdW Woc/4pofkuoYF4gQ8fGSEOO9fQaCqS2SqokzKAR3aDDv7crK5pPfX/nz mqbPclm6jq63um4I0cjgnIM5ceoV6UM4m9sFqaTDXfqqWafQMfIXy2s1 RqxtWt4J0naFOFFNH2SkdHN6gngQDCDPXRJfXnzMof7F3qXWMvWS1uKR OSleF+6B/cJMve+nJqrGnwzktVkDNVqQ8bfl7kwO1peiNZqJ9FIpPz6r 1hpmVA== ;; Received 1175 bytes from 198.97.190.53#53(h.root-servers.net) in 97 ms example.com. 172800 IN NS a.iana-servers.net. example.com. 172800 IN NS b.iana-servers.net. example.com. 86400 IN DS 31589 8 1 3490A6806D47F17A34C29E2CE80E8A999FFBE4BE example.com. 86400 IN DS 31589 8 2 CDE0D742D6998AA554A92D890F8184C698CFAC8A26FA59875A990C03 E576343C example.com. 86400 IN DS 43547 8 1 B6225AB2CC613E0DCA7962BDC2342EA4F1B56083 example.com. 86400 IN DS 43547 8 2 615A64233543F66F44D68933625B17497C89A70E858ED76A2145997E DF96A918 example.com. 86400 IN DS 31406 8 1 189968811E6EBA862DD6C209F75623D8D9ED9142 example.com. 86400 IN DS 31406 8 2 F78CF3344F72137235098ECBBD08947C2C9001C7F6A085A17F518B5D 8F6B916D example.com. 86400 IN RRSIG DS 8 2 86400 20171011042652 20171004031652 5528 com. CdiFjCZayrnvnBJLJkIu4Y3ze0Tt1Ee0EQGncFteAVlMynR+OZLVj3yl x5gR8eoz60J2GJBitaRF7ShIThqFJANhZj2UNVgGTj2MwIoKdSYa9RzW MFl5jDtccwPQlz9ExQRsKdhWvR+NmHzxZGL8i3Jn1mlYy/zlDBhcOnT1 PVs= ;; Received 595 bytes from 2001:503:231d::2:30#53(b.gtld-servers.net) in 61 ms www.example.com. 86400 IN A 93.184.216.34 www.example.com. 86400 IN RRSIG A 8 3 86400 20171015151339 20170924131703 15819 example.com. UGzI8J1fpRC4ckqAGmRngSfcWuu3W8q+d6JusiM8JG0ofH3YAdsHH0lF jWt5vyb/VUVEy/9VBU9bg97EokbTivETfESA3kIePbUtm5RGMPs+rTO0 KwyOqU5LzmHtwJTrYHzkN8QxTBZfX77//PGoiVfZturMLZxNIO6jg9Ke Vcf7Mao= example.com. 86400 IN NS b.iana-servers.net. example.com. 86400 IN NS a.iana-servers.net. example.com. 86400 IN RRSIG NS 8 2 86400 20171015113637 20170924071703 15819 example.com. MwSG+cV2YIqswOOkBXVNmMUx4jVg3sGe4cOrRjmAg8fwNfx/OxC7QUbt vjeseYXDtYECEfVKjaPlPh8P7YhlI1WQvm3QVYf3z0avd67UYBJPZH7i h++xg6X+n3uBtYigkgIJ4l7fTZ9bYwEyEwFuqVjkiYOEkIH4MBjeCVeM NUtIyCQ= ;; Received 544 bytes from 199.43.133.53#53(b.iana-servers.net) in 43 ms Check your output. The last section contains most of the useful information. Notice the line www.example.com. 86400 IN A 93.184.216.34. This means that the DNS lookup retrieved an A record pointing to 93.184.216.34 for the \u0026ldquo;www\u0026rdquo; subdomain. All queries for www.example.com will be instructed to visit that IP address. The record has a TTL of 86400 seconds, meaning that DNS servers are instructed to cache this value for 24 hours and any DNS changes will take up to that long to be completely propagated globally. Another feature of interest is the following: example.com. 86400 IN NS b.iana-servers.net.. This specifies the name servers for your DNS hosting company and the place where your DNS configuration is managed. After a successful DNS change onto Section, your main website domain (www.example.com) should have a CNAME record (or an ALIAS record in the case of a bare domain) pointing towards the section CNAME record visible on the DNS tab in the Section portal. For example: www.example.com. 86400 IN CNAME www.example.com.c.section.io","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/domains-dns/check-your-current-dns-setup/","objectID":"3d503d480c1143e915939f3ff1db5420_0","order":0,"tags":null,"title":"Check your current DNS setup"},{"content":"Before you deploy, make sure you have set up an example Node.js app. Find the name of your app Find the ID of your account: sectionctl accounts The output will look something like this: | ACCOUNT ID | ACCOUNT NAME | |------------|-----------------------------------| | 1335 | g9ts24tx7gm8n12b2evf3.section.dev | Note the number value in the account ID column – we\u0026rsquo;re about to use it to list applications you have access to: sectionctl apps list --account-id 1335 The output will look something like this: | APP ID | APP NAME | |--------|-----------------------------------| | 7171 | g9ts24tx7gm8n12b2evf3.section.dev | The application name was automatically generated for you when you signed up. Note the name of the application that is returned – you are going to use it in the final steps. Set up the SSL certificate for your domain Section provides SSL certificates for your apps for free. To set up this up so your app is available, run: sectionctl certs renew --account-id 1335 --hostname g9ts24tx7gm8n12b2evf3.section.dev (make sure to substitute your account ID and domain when you run this command) Deploy your app Now your app is ready to deploy: sectionctl deploy --account-id 1335 --app-id 7171 (make sure to substitute your account and app IDs when you run this command) This will take a few minutes to upload and deploy your Node.js app to Section\u0026rsquo;s edge. View your app running on Section Plug the app name you saw above into your browser, and you should see your app running. Node.js Edge App Hosting is a new Section product, so it may have some rough edges. If you see something that needs improvement, we\u0026rsquo;d love to hear your feedback. See the state of an application You can use the following command to see the state of an application sectionctl ps --account-id 1337 --app-id 7171 This will return the status of running app instances in the following format: | APP INSTANCE NAME | APP STATUS | APP PAYLOAD ID | |-------------------|------------|--------------------------------------| | nodejs-flwp6-3b4 | Deploying | 69be5c29-9f02-41dc-bed0-27cff1cbbbaf | | nodejs-7xzhf-0d3 | Deploying | 69be5c29-9f02-41dc-bed0-27cff1cbbbaf | | nodejs-a8sfs-23e | Running | 2ea3e806-706d-4af2-bd8c-3d45ba4b634b | | nodejs-sdfk5-54s | Running | 2ea3e806-706d-4af2-bd8c-3d45ba4b634b | The example above shows: two running instances of the application on a previous version as indicated by the payload ID. two app instances being deployed with the latest version. Once an app instance finishes deploying, its status will change from Deploying to Running, and replace the app instances running the older version: | APP INSTANCE NAME | APP STATUS | APP PAYLOAD ID | |-------------------|------------|--------------------------------------| | nodejs-flwp6-3b4 | Running | 69be5c29-9f02-41dc-bed0-27cff1cbbbaf | | nodejs-7xzhf-0d3 | Running | 69be5c29-9f02-41dc-bed0-27cff1cbbbaf |","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/launching-a-nodejs-app/deploy-your-nodejs-app/","objectID":"607024580ab6341a60375a5337dfce0e_0","order":0,"tags":null,"title":"Deploy your Node.js app"},{"content":"1. Locally Override DNS to point at the Developer PoP You will need to modify your local host file and point the Hosted Name(s) for your service at the IP address given by the command minikube ip. 192.168.99.100 www.example.com This will override the DNS endpoint for that domain and force traffic through the Dev PoP and then to your origin address. Your origin could be your production webserver, production load balancer, development webserver — whatever you configured for in the Dev PoP UI. Now when you browse to your site URL, the HTTP traffic will be flowing through the Developer PoP! 2. Provision SSL certificate If you visit your website at this point in the tutorial, you will likely see a browser security warning. While it is totally possible to skip this step, click through this warning and test your site without a problem, our Dev PoP can provision a certificate for your local cluster. On the top right hand side, click on the download root certificate button. Download Local Root Certificate a) For Windows Right click on the section.io-developer-pop-root certificate in your downloads folder and select install certificate. Click through the wizard and install the certificate. Once installed, you should see the DO_NOT_TRUST_sectionio_root in the security tab of your browser dev tools. b) For Mac Double-click on the certificate in your downloads folder and add it to the appropriate keychain. Once completed, you should be able to see DO_NOT_TRUST_sectionio_root under Category certificates. Right click on the certificate and select Get Info. Under the Trust section select the option Always Trust for When using this certificate. As with Windows, once installed properly the DO_NOT_TRUST_sectionio_root should appear in the security section of dev tools. 3. Making changes to your configuration Now that you have traffic flowing through the Dev PoP you will be able to change any configuration and see it live within a few seconds. Using your favorite editor, open the repository you cloned from Aperture. Whether you have Varnish, PageSpeed, or a Web Application Firewall, you can change the configuration to see how your application will behave. Once you have made changes to your config, you will want to push them to the Dev PoP to see them in action. Again we will be using a typical git workflow: Stage your changes: git add .. Commit your changes: git commit -m \u0026quot;Some relevant message here\u0026quot;. Push your changes: git push developer-pop. If you have syntax errors git will provide feedback. You may need to make adjustments and go back to step 1. Go back to your browser, reload the page, and see what type of optimizations your changes made. Congratulations! You have successfully set up the Section Developer PoP! See below for miscellaneous tips to help you get the most out of the software. Further Reading For a guide on troubleshooting common Developer PoP issues. For a guide on setting up DevPoP with a local server.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/developer-workflow/developing-with-the-developer-pop/","objectID":"017f9c1432933f8d5deafb5367c01f34_0","order":0,"tags":null,"title":"Develop with the Developer PoP"},{"content":"Turning on automatic HTTPS In the management console, click HTTPS in the left hand menu. Click Renew Certificate. You\u0026rsquo;ll get a message saying that your certificates have been set up. Congratulations! You are now live with Section. If you have any trouble, consider looking at our HTTPS Troubleshooting guides.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/going-live/enable-automatic-ssl/","objectID":"30021fe282c829d16adbb73c7bd8b203_0","order":0,"tags":null,"title":"Enable Automatic SSL"},{"content":"WHY: Based on your metrics evaluation, you should have identified areas you want to improve. These changes will help you get the most out of Section HOW: To optimize your configuration, please visit our modules page and browse our guides on the modules in your stack.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/performance-optimization/optimize-your-configuration/","objectID":"d5592c324043f53af6ebcf448d08cbef_0","order":0,"tags":null,"title":"Optimize your Configuration"},{"content":"What is HTTP(S)? HTTP is a protocol for how web requests are handled. HTTPS is an enhanced version of that protocol to add security by encrypting your customers data so it is protected from threats. You can see when a webpage has HTTPS because the url will show a green padlock. Why is it important? The percentage of requests that have HTTPS show how often your customer data is protected. If this ratio is low, you are putting your customers’ data at a higher risk for incident. Websites which serve entirely over HTTPS can also take advantage of the performance benefits of HTTP/2 and will be ranked higher by Google in search results. How can I see my HTTP(S) requests? You can view your websites breakdown of HTTP vs HTTPS under Real-Time -\u0026gt; HTTP Logs. To build a nice pie chart, you want to filter by _type:edge-access-log which limits the count to only requests to the edge proxy and then split by scheme which indicates HTTP or HTTPS. You can see the example for Bootcamp Bootcamp HTTP vs HTTPS Ratio Piechart.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/performance/uncover-how-often-you-are-using-https/","objectID":"eac4b4d7142d9fe953ce914fda3c9b79_0","order":0,"tags":null,"title":"Uncover how often you are using HTTPS"},{"content":"The Section platform runs a high availability Global Network so that your Application Edge is ready when and where your customers need it. Section forms its Global Network by combining the network, compute and security features of the most popular cloud services such as: Amazon AWS Google Compute Engine Microsoft Azure DigitalOcean Packet Rackcorp Our reach continues to grow as Section incorporates more cloud providers into its Global Network. If there are other providers that you\u0026rsquo;d like to use with Section, reach out and let us know — we are always looking to expand our service offerings. Run in your own cloud accounts If you have your own cloud services, you can run Section as a private setup within your own facilities. This can give you peace of mind, cost advantages, or help you reach compliance requirements unique to your situation. Replace your Application Delivery Controller The Section platform can also be run on your origin infrastructure, such as a classic application delivery controller. You can deploy a single instance or a high availability cluster right in your own datacenter or cloud account. Section brings a wide variety of software that can be run in a point of presence. Learn about the types of reverse Proxy Options you can run inside Section.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/global-network/","objectID":"2980eeda798b3839831b8b43a054e23b_0","order":0,"tags":null,"title":"Global Network"},{"content":"WHY: Everytime you change your configuration, Section will log that history. This allows you to see what was changed and then review metrics to see how your site performed before and after the change. HOW: In the repository tab under commits you will see a list of the commits that have been made to your application. You can see what that looks like for Bootcamp here.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/performance-optimization/track-your-changes/","objectID":"6ad9799c63315e741c5b4cb1370a5d23_0","order":0,"tags":null,"title":"Track your Changes"},{"content":"WHY: You may not want to be checking your metrics everyday, but you want to know if something is wrong so you can fix it. With Alerts you can set benchmarks for your metrics and be alerted via your preferred notification system. HOW: Under the alerting tab you can identify a metric using graphite query string and at what value you want to be alerted. More details here. For more in-depth guides on evaluating your website\u0026rsquo;s performance and activity, see our debugging and monitoring guides.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/performance-optimization/monitor-your-website/","objectID":"618998b794d05f1d5a14b46b0cbeb2b9_0","order":0,"tags":null,"title":"Monitor your Website"},{"content":"Unlike Legacy CDNs which generally are fixed on a single proxy, Section allows you to choose the proxies that suit your application architecture. Depending on your needs, you can run a single module or combine multiple modules for enhanced performance benefit: Performance: Varnish Cache (versions 3, 4, 5, 6). Google\u0026rsquo;s PageSpeed. Nginx, and Nginx+Lua. Scalability: Varnish Cache . Nginx. Availability: Varnish Cache . Nginx+Lua. Security: ModSecurity. ThreatX. Signal Sciences. These are just some of the reverse proxies that are available to you. Pick the right combination and painlessly change them as your requirements change. All of these proxies are available throughout the entire development lifecycle.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/proxy-options/","objectID":"38c9d98c4d0997b318598eae78c236e3_0","order":0,"tags":null,"title":"Proxy Options"},{"content":"For too long, CDNs have remained in the dark ages of waterfall processes with no integration into the agile development lifecycle. Agile methods just aren\u0026rsquo;t something that CDNs understand. As application logic moves to the edge, Section brings the tools and processes you need to build an ideal, flexible architecture. By allowing any engineer in your team to run a Developer PoP, you can bring the Application Edge right down onto your laptop. This means you can adjust the Application Edge configuration on the fly, right where you write your code. Get it right on your laptop, then use Git to promote your work. Use feature branches to experiment with new code with all the production proxies working locally, and when you, your team and your CI platform are happy, promote those changes to production with normal merge strategies. No more worrying about whether your code will be affected by the CDN configuration when you release, and no need to be scared when you make changes to the CDN configuration. Of course, once you\u0026rsquo;ve released your application, Section is DevOps Ready to help you attain deep, real-time insights into your HTTP traffic.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/developer-ready/","objectID":"a7244654185857cdcafe01567bcffd7e_0","order":0,"tags":null,"title":"Developer Ready"},{"content":"Whether a website is yours or your client\u0026rsquo;s, you need to have the right information available to you immediately when you\u0026rsquo;re running a mission critical application. Section runs a detailed, real-time logging and metrics platform to provide you with the vital diagnostics. DevOps teams need a few things to get their job done well: Continual improvement: Section collects hundreds of metrics about how your HTTP traffic is performing and provides long term retenion out of the box. Incident detection: Section allows you to configure alerts for any metric in the platform. Incident management: when things go wrong, use the real time metrics to identify problems and then dig right into the HTTP logs to isolate individual requests. Legacy CDNs fall short of these needs in a couple of ways: either their log shipping latency is too slow (sometimes an hour after your problem started), or they fail to process those logs into meaningful and actionable information. Section also makes sure that these metrics and logs datasources are made available in familiar formats, so you can integrate them into your existing operational toolchain. Use your existing monitoring stack to get alerts, without \u0026ldquo;yet another alerting platform\u0026rdquo;. Learn more about Section DNS Options.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/devops-ready/","objectID":"4ef1002fee21d2c66c5031e5c4c3f9f3_0","order":0,"tags":null,"title":"Devops Ready"},{"content":"Section uses DNS to route requests to the most appropriate datacenter. When you sign up for Section, you configure a CNAME record to point your traffic to our Application Edge, just like a legacy CDN. Section also includes a global anycast DNS network with all plans. This can be useful if you run your site as a bare domain. Whilst you can choose to move your DNS to our nameservers, that\u0026rsquo;s completely optional at all plan levels. Learn more about Section HTTPS Options and capabilities.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/dns-options/","objectID":"21b13d5327232abfddeb1ad67df25c2f_0","order":0,"tags":null,"title":"DNS Options"},{"content":"All Section plans include a complete HTTPS solution. On our platform you can: Take advantage of our free SSL certificates that are automatically configured and renewed. Upload your own Standard, Wildcard, or Extended Validation certificate","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/https-options/","objectID":"7385f4fc4549e9401451791772107c19_0","order":0,"tags":null,"title":"HTTPS Options"},{"content":"Configure Caching and HTML Streaming Set the static caching and HTML Streaming features toggles to true. sub vcl_recv { # Section feature toggles. if (!req.http.section-enable-static-caching) { set req.http.section-enable-static-caching = \u0026quot;true\u0026quot;; } if (!req.http.section-enable-html-streaming) { set req.http.section-enable-html-streaming = \u0026quot;true\u0026quot;; } } Configure HTML Streaming by whitelisting paths. # SWITCH for HTML streaming, if(req.http.section-enable-html-streaming == \u0026quot;true\u0026quot; \u0026amp;\u0026amp; (req.url ~ \u0026quot;(?i)^/(?=\\?|\u0026amp;|$)\u0026quot; || req.url ~ \u0026quot;\\/sale\\/shoes\\/.*\u0026quot; || req.url ~ \u0026quot;\\/outlet\\/promotion\\/.*\u0026quot; || req.url ~ \u0026quot;\\/men\\/new-arrivals\\/.*\u0026quot; || req.url ~ \u0026quot;\\/outlet\\/boys\\/.*\u0026quot;)){ Location Optimization Section can locate cached and HTML streamed content in the region closest to the customers end users. Such locations include: Asia Pacific region. Europe region. North America region. Contact Section support to for adjustments to locations: contact us.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/bigcommerce/optimize-bigcommerce/","objectID":"3001e6b3b35c14408e05fb0e8add5fd2_0","order":0,"tags":null,"title":"Optimize Bigcommerce with Section"},{"content":"The following is a guide to going live on Section with a Magento 2 application. 1) Download the Section extension. a) Via the Magento Marketplace To get started with Section and Varnish Cache directly from the Magento Admin portal, you first must download the \u0026ldquo;Instant Global Cache\u0026rdquo; extension from the Magento Marketplace. b) Via the command line Add \u0026quot;sectionio/metrics\u0026quot;: \u0026quot;dev-master\u0026quot; to your composer.json file and run composer update. This assumes that your application is configured to pull from Packagist. 2) Connect your Magento application to your Section account. Once the extension is added, click on Reports in the left Nav. A Section option should now be listed among your reports. a) Set up via the Admin portal Inside the Section reports view, you will see fields requesting your Section credentials. If you\u0026rsquo;ve already created an account on our platform, enter those credentials here. Othewise, You can also create an account from here in the Magento portal or on our website: [section.io/sign-up/] (https://www.section.io/sign-up/). When you create your login, we will also send you an email to verify your email address. This is required for us to setup your application. b) Set up via the command line In order to link your Section account to your Magento application via the command line, you need to have already created an account( section.io/sign-up/). Once your account is created and the Section extension is installed inside your app, your magento binary should have access to the sectionio:setup command. From the root of your application, run bin/magento sectionio:setup \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; \u0026lt;account_id\u0026gt; \u0026lt;application_id\u0026gt;. A successful execution produces no output. If it executed successfully, you should see your account information displayed in the Section reports tab within your admin portal. Note: After running this command, run bin/magento setup:upgrade and bin/magento setup:di:compile. 3) Set up your application and Varnish Cache . When you are logged in on your Magento Admin Portal with your Section credentials, we will determine if you already have an application setup with us. If you do, we will show you the accounts you have with us. If you do not, we will create an application for you. If you do not have Varnish Cache as your chosen Full Page Cache Caching Application, we will show an error message for you to update this. To update this field, go to Stores -\u0026gt; Configuration (under Settings) -\u0026gt; Advanced -\u0026gt; System. Then toggle the Caching Application under Full Page Cache to Varnish Cache . Now you have a Section application created with Varnish Cache 4 and Varnish Cache setup as your Full Page Cache solution in Magento. 4) Import Magento Varnish Cache configuration a) Import via the Admin portal On the Section extension, you will see a Management section. The first button says “Update Varnish Cache configuration.” Clicking this button will pull in the recommended Magento VCL (Varnish Cache Configuration Language) into your Section application to optimize your caching for Magento. b) Import via the command line You can also import your vcl configuration using the bin/magento sectionio:updatevcl command. The effect of this is identical to the \u0026ldquo;Update Varnish Cache configuration\u0026rdquo; button described above. As with the other CLI commands, success is silent. 5) Provision a free Section certificate (optional) There is also a button to pull in free HTTPS certificate. This will ensure your website has the green padlock next to the url. This is a free certificate included with your Section application that we will managed on your behalf, to include procurement, installation, and renewal. Please ensure your website has an endpoint exposed to the internet so we can validate the certificate before you go live. note: if you do not perform this step, you will need to upload a custom certificate to the Section portal in order to maintain HTTPS. (See our guide ) 6) Change DNS and Go Live! To go live with Varnish Cache and your Section application, you will need to change a DNS record to point to Section. Detailed instructions can be found here. You can also find more information from your hosting provider as to where to go to make this change. Once you have made the change, you can click verify to see if the change was successful and traffic is currently flowing through Section. Additional Settings: Include CMS in Product Purges When a product is updated either via checkout event, image update, description change or other similar event, Magento clears the cache for all pages where that product is mentioned, including the home page, category pages, and product pages. Although it is important to clear cache when product information changes, often this internal cache-clearing protocol clears the cache on non-product pages unnecessarily, exposing your origin to additional traffic and slowing down response times. Although the Section Magento extension forwards all cache-clearing directives to your cloud Varnish Cache instances out of the box, it can be configured to ignore cache clear requests for CMS pages. To enable this feature, navigate to Stores-\u0026gt;Configuration-\u0026gt;Advanced-\u0026gt;System-\u0026gt;Full Page Cache-\u0026gt;Section settings. Here you can toggle whether CMS pages are included in automated cache purges. Note: enabling this feature means that if you change key elements of a product like the name, other pages that feature the product will need to be manually cleared. Overall, this configuration option will have a positive benefit on site performance at the cost of some manual overhead. Whenever you update a product, you need to clear the relevant caches in the admin console.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/magento-setup/set-up-magento-2/","objectID":"e639d646b784d2d881f8087d15dab79a_0","order":0,"tags":null,"title":"Set up a Magento 2 app on Section"},{"content":"The following is a guide to installing the Section Drupal module into an existing Drupal 8 application. This module allows Section\u0026rsquo;s global, distributed caching layer to quickly respond to invalidation events from a Drupal instance in exactly the same way that Drupal\u0026rsquo;s internal cache or a local varnish cache running on the host machine does, ensuring that the content in Section\u0026rsquo;s global caching layer is never stale. Prerequisites An existing Section application. For help setting up an application, go here A user account to be associated with the Drupal Module (many customers choose to create a user account that exists simply to authenticate cache clearing and is not associated with a specific, real person). To create an account please contact us at this link and for help adding a new user to an app please see here The Drupal 8 purge module installed. The Drupal 8 key module installed. Drush installed if you want to purge any invalidation type over CLI. (requires purge 8.x-3.x-dev or newer for Drush 9 support) Modify your VCL to disable cache on certain pages like admin panel. Here\u0026rsquo;s an example, but lots will probably need to be changed for section. The blocks of code within if (req.method == \u0026quot;BAN\u0026quot;) and if (req.method == \u0026quot;PURGE\u0026quot;) are not necessary on section because bans are handled via the API. You may also want to prevent caching (pass) on pages with certain cache tags: obj.http.Section-Cache-Tags ~ \u0026quot;4bt8\u0026quot; (hash of config:user.role.authenticated) obj.http.Section-Cache-Tags ~ \u0026quot;3vnt\u0026quot; (hash of config:user.role.administrator) and/or obj.http.Section-Cache-Tags ~ \u0026quot;r8q3\u0026quot; (hash of config:system.menu.admin) Alternately you can pass on caching pages if there is a session cookie. Download the Section Purger This module can be found here. Download the latest release as a zip/tar file and load into your Drupal instance. We also support installing via composer. Enable Purge and Section Purger Modules Click the Extend tab in the admin console or otherwise navigate to /admin/modules. If the Purge module is installed correctly, this page should contain a section called PURGE with various available submodules. Enable the Purge, Purge Tokens, and Purge UI submodules. We are also compatible with Drush but it is not required. You also need to enable a way to process cache invalidation items. You choices are the Cron processor and the Late runtime processor.The Cron Processor will process cache invalidations only when the cronjob is run (it runs automatically on a predefined schedule or you can initiate it manually from the admin console), while the Late runtime processor will process the purge queue when a page is requested. It does not matter to our module whether you choose either or both, however in production environments, you should only be using cron as there would be a significant page load time increase with the late runtime processor as it would need to make an api request every time a purge is in the queue, and if the request times out the end-user may get a 500 internal server error thrown by Drupal. Finally, enable the Section Purger module and the Core Tags Queuer. This module ensures that Drupal sends the appropriate cache tags that our module uses to evict expired assets from the cache. Safely store your Aperture Password with the key module Navigate to /admin/config/system/keys/add and input your section.io password. Use key type Authentication, and choose whichever key provider you find to be the safest in your particular environment. (More info on this in the key module documentation). Configure Full Page Cache Max Age Navigate to /admin/config/development/performance and set Page Cache Max Age to whatever value you prefer. Since the extension is clearing the cache whenever a change event occurs, there is no need to wait for object resources to expire naturally and you can safely choose 1 year. Varnish Cache\u0026rsquo;s default behavior is to cache according to the cache-control headers on the response, but Varnish Cache can also be configured to set its own internal TTL value for cached objects based on content-type, status, or other response attributes. For more information on this, please see our Varnish Cache guides. Enable the Section Purger within the Purge UI Navigate to /admin/config/development/performance. If your installation of the purge module succeeded, you\u0026rsquo;ll see a Purge tab next to the Performance tab at the top of the page. Next, click on Add Purger to open the UI to create a new Purger and select Section Bundled Purger. Once created, you should see a flash message informing you that the purger has been successfully created. The Section Bundled Purger combines API requests for tags, which reduces processing time on the origin, and potentially page load time if you are using the late runtime processor (cron is best for production environments). Next, click on the small arrow next to the purger and click configure. This will open the UI to fill in your account credentials and connect your Drupal module to the Section platform. Note: The Drupal Site Name field should be the full hostname of the site for which you are configuring the purger, and is only necessary when setting up a Drupal 8 multisite. If your Drupal instance is not a multi-site, then this field can be left blank. Note: Varnish Proxy Instance Name field will usually be varnish. This name is defined in the section config in your application\u0026rsquo;s repository. This is useful if, for example you have multiple varnish instances that handle different things. You can set up a purger for each instance of varnish (if using Drupal site name, this would be per-instance and per-site-name) Once here, input the details of the user account you would like to use to authenticate with our API. Once done, click Save Configuration. Once saved and configured properly, the status bar on the right hand side should show all green as pictured below. Check the logs to confirm that queuer is working (optional) You can set the logging levels from the block on the right sidebar on the purge page. (/admin/config/development/performance/purge) You can view the logs at /admin/reports/dblog Raise the","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/drupal-setup/set-up-drupal-8/","objectID":"3b659b1809844e72b17ab39695c63919_0","order":0,"tags":null,"title":"Set up Drupal 8 on Section"},{"content":"timeout if necessary If you are seeing timeout errors connecting to aperture, raise the timeout in the purger settings. We recommend a timeout of 2, but feel free to increase this to 5 when using the cron processor.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/drupal-setup/set-up-drupal-8/","objectID":"3b659b1809844e72b17ab39695c63919_1","order":1,"tags":null,"title":"Set up Drupal 8 on Section"},{"content":"Time To First Byte (TTFB) Time To First Byte is an important metric for user experience as people do not wait for slow pages to load. TTFB is a metric of the time taken for a user to receive the first byte. Start render time is crucial because it represents the time the user is waiting while looking at a blank screen. There is a high correlation between start render time and bounce rate, so significantly improving this metric has tangible business benefits. HTML Streaming HTML Streaming uses Varnish ESI and OpenResty to punch a hole in the HTML DOM and can stream the HTML behind the title tag, but allows the loading and caching of the head of the document. Dynamically cache parts of HTML document without caching elements of the page that are unique to the user. HTML streaming improves load time metrics and user experience without requiring complex application changes. Achieves faster page load times. HTML streaming dramatically improves the start render time on applications that are not yet caching their entire HTML document. Unlike dynamic content caching, HTML streaming does not require an intensive implementation time or code changes to your origin and can very quickly realize most of the gains of dynamic content caching within hours of enabling the feature with the help of Section\u0026rsquo;s engineers. HTML Streaming is fast to implement because it does not require changes to your origin and you don’t need to learn more advanced caching strategies or advanced VCL. Before Section HTML Streaming Using a standard store and testing from Sydney Australia. Before HTML Streaming is enabled TTFB is approximately 1500ms on the homepage of a Bigcommerce site using the permanent URL. After Section HTML Streaming After HTML Streaming and caching is enabled TTFB is approximately 190ms on the homepage. After Section caching and HTML Streaming is enabled, from Australia, we generally see an approximately 80-90% improvement in TTFB.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/bigcommerce/ttfb-bigcommerce/","objectID":"9c4ff9e044206cc877ab3477bca7f046_0","order":0,"tags":null,"title":"TTFB Bigcommerce with Section"},{"content":"Options to optimize HTML: HTML Streaming - https://www.section.io/html-streaming/ Anonymous User Caching (Recommended) - https://community.section.io/t/a-novel-way-to-cache-html/79 Turpentine - Detail below Set up Varnish Cache Caching Magento 1.9 and earlier does not support Varnish Cache out of the box. Support is instead provided by the [free Turpentine Magento extension]. The Turpentine extension issues commands required for correct operation to a management port intended for Varnish Cache. A special “bridge” program listens on this port, and makes the Section platform look like a normal Varnish Cache instance (Instead of a globally distributed platform that runs Varnish Cache for you). Follow the official instructions in order to install Turpentine. Since Varnish Cache itself is already configured inside Section you’ll only need to complete the ‘Install this plugin’ steps. Sign up \u0026amp; create an application at Section using the final DNS name that your site will be accessed as. Download, install \u0026amp; configure the varnish-cli-bridge. Follow the standard Magento+Turpentine instructions, with some exceptions (see below). Apply the Varnish Cache configuration from within Turpentine Configuration, to update Section. Update your public DNS records to direct traffic to Section for your site. Create an application Section provides a customized Varnish Cache image already configured for Magento Turpentine. Create your application using the Stack “Varnish Cache v3 Magento Turpentine”. Set up the varnish-cli-bridge This program will listen for Varnish Cache commands and foward them to the Section hosted Varnish Cache platform. Download Download the lastest Section cli bridge here. You will want the varnish-cli-bridge-vN.N.N-linux-amd64.tar.gz file. Collect configuration details There are 3 pieces of information required to run the bridge: API endpoint: This URL uniquely identifies your application within Section. Most often, you’ll need the “Production Varnish Cache Proxy API endpoint” from the Configuration \u0026gt; API page in Section’s management portal. API username: This is a username that has permission to perform API actions. API password: This is a password for the specified user to perform API actions. Run as a service We have an Upstart script available to to run the bridge as a service. Install Upstart if it is not already installed on your server. Copy the script above with the new name “varnish-cli-bridge.conf” into /etc/init/. Change the endpoint, username \u0026amp; password to match your application. # Step 1: Install Bridge cd /tmp curl --remote-name --location https://github.com/section-io/varnish-cli-bridge/releases/download/v0.2.4/varnish-cli-bridge-v0.2.4-linux-amd64.tar.gz tar xvzf varnish-cli-bridge-v?.?.?-linux-amd64.tar.gz cp ./varnish-cli-bridge /usr/local/bin/varnish-cli-bridge # Step 2:Setup bridge to run cd /etc/init curl --location https://github.com/section-io/varnish-cli-bridge/raw/master/upstart.conf --output varnishclibridge.conf # Step 3: edit the file \u0026quot;/etc/init/varnishclibridge.conf\u0026quot; with your specific details vi varnishclibridge.conf # Step 4: State the Varnish Cache cli bridge as a service start varnishclibridge # Step 5:Check bridge log for success - Should see a line like this -\u0026gt; main.go:159: Listening on '127.0.0.1:6082'. tail /var/log/varnish-cli-bridge.log Otherwise, use whatever solution is available with your distribution to run the binary as a service. Configure Turpentine to talk to the bridge In your Magento admin portal, you will want to navigate to the Turpentine \u0026ldquo;Varnish Cache Options\u0026rdquo; section. Here we will be updating the Server List option with the endpoint for the Varnish Cache CLI Bridge you just installed. Add the entry 127.0.0.1:6082 to the list and hit \u0026ldquo;Save Config\u0026rdquo; in the upper right hand corner. If you get an error (sample error in picture below), you should revisit the bridge installation process and ensure you have done that correctly. Deviations from official Turpentine instructions Installation See the turpentine installation guide. Step 1-3: Skip these steps. There is no need to install or configure a local Varnish Cache server. Configuration See the turpentine configuration guide. No special configuration is required to use Turpentine with the bridge \u0026amp; Section. Upload Turpentine configuration to Section The configuration must be applied/uploaded into Section by manually hitting the Apply Varnish Cache Configuration button on the Cache Management page. Testing There are 2 recommended tests to validate your implementation: Test Pages Are Coming From Cache - Reload your browser 3-5 times on a single page, You should start to see multiple Varnish Cache ID’s in the HTTP response headers (In a browser debugger such as Chromes debugger) and see page response times around ~50-100ms Test Bans Are Reaching the Section Platform - Using a Product page on your site refresh 3-5 times to ensure pages are in cache. Once the page is in cache, Add a product to your shopping cart. This will cause Turpentine to send a Ban statement to Section to clear out the block on all pages for the user that contains the shopping cart. You should see the shopping cart updated successfully on page refresh.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/magento-setup/set-up-magento-1/","objectID":"2de2406174cb72a20abb9e3e56379bff_0","order":0,"tags":null,"title":"Set up and optimize Magento 1 on Section"},{"content":"Bigcommerce optimization on Section with caching, location optimization and HTML Streaming are paid features and managed services, please contact us to learn more. Create a Bigcommerce store Sign-up at Bigcommerce to set up a store and assign a domain. Sign up \u0026amp; create a store at Bigcommerce. Use the final DNS name that your site will be accessed. Follow the standard Bigcommerce instructions to add the domain to the Bigcommerce site. Configure an SSL certificate on the Bigcommerce store to force SSL HTTPS everywhere. Update your public DNS records to direct traffic to Section for your site. Create a Section application Create an application to get started and contact support who will finish custom configuration. Sign up \u0026amp; create an application at Section using the final DNS name that your site will be accessed. Choose the Varnish module during application creation to begin the configuration. Contact Section support to finish configuration: Contact us. Related Optimize with Section Optimize Bigcommerce with Section by configuring static asset caching, HTML Streaming and location optimization.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/tutorials/integrations/bigcommerce/set-up-bigcommerce/","objectID":"2d7d12223ecb09c1414aef47cd81d0cc_0","order":0,"tags":null,"title":"Set up Bigcommerce on Section"},{"content":"Overview of the key entities and account structure referred to throughout Section. Component Function Description Account Organization Users can be associated with one or many accounts. Accounts represent organizations like businesses. The Account is the master structure of Section. Accounts may contain many Applications and Users. API API Section JSON RESTful API to manage the users, accounts, applications, environments, domains and logging. Aperture Dashboard Section web portal to manage the users, accounts, applications, environments, domains and logging. Application Website configuration Configuration for your content-delivery and proxy setup, monitors HTTP traffic from the client through your proxy stack to your origin and back again, and manages the state of your website content. Generally an Application is defined by the url for a website or web Application. Each Application may have multiple Environments (e.g. Production and Development) and can have multiple Users with access to the Environment(s) for that Application. Domains www.yourdomain.com mysecond-domain.com Each application can also have multiple domains for any number of websites with the same proxy configuration setup, greatly simplifying the management process for many similar sites. Edge Proxy Ingress / Edge Proxy Every application proxy stack begins with the Edge proxy. Environment Staging, Development, Production etc Environment defines the functional space within which the Proxy Instance is working for the Application. Section means Users can seamlessly move a Proxy Stack configuration between Environments. An application supports multiple environments like staging, development, and production on git branches within the application repository. Each of these environments can have different proxy configurations. Instance Software \u0026amp; Configuration Each User’s copy of the Proxy Stack for the application is referred to as an Instance. Generally, there will be multiple Instances of the Development Environment where there are multiple users working on the Proxy Stack for that Application. Usually, there will be only one Production instance and in normal development workflows, a limited number of instances for Test or Staging Environments. Modules Software \u0026amp; Configuration Section offers modules of open source and commercial software solutions that form a proxy stack. Proxy Reverse Proxy A Proxy or \u0026ldquo;Reverse Proxy” is the server handling requests within each environment e.g. Varnish Cache. A Proxy (or more technically correct “Reverse Proxy”) is the server handling requests within each environment (e.g. Varnish Cache ). The nature and configuration of the Proxy is subject to the changes a user may make in the respective environments. Section’s commands can then be called to synchronise the configuration of the Proxies between the Instances in each Environment. Proxy Stack Chained Proxies Where more than one Proxy is “chained” together we refer to this as a Proxy Stack. Where more than one Proxy is “chained” together we refer to this as a Proxy Stack. E.g Combining two Proxies to work together such as Varnish Cache and Mod Security or Varnish Cache and Nginx would provide the user with a Proxy stack. Support Customer Engineers Section is a managed platform and Customer Engineers are ready to support. User User management Users can manage accounts, environments, applications etc. Users are defined by an email address. There may be many users per Account. A User may haver access to more than one Account. Each User may have access to multiple Environments within any Account. e.g. Development and Production","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/platform-checklist/","objectID":"894ae2a92850867f9950a87d6e1bdee2_0","order":0,"tags":null,"title":"Terminology"},{"content":"Section offers a number of different modules that can be used in your edge deployment. Section also allows you to build your own modules and run custom workloads on our edge network throughout the world. You can get started with building your own module with the example module assets provided by Section : Module Build Assets. A module template is a combination of the module software (eg. Varnish Cache) and a set of default files to configure the module (eg. the default.vcl file). If you want to experiment with different modules you can use our Developer Workflow to run your edge deployment on your local machine. Available Modules Module Function Description Cloudinary Image Optimization On-the-fly image manipulation and optimization. Optidash Image Optimization Optimize images and reduce page weight and load time. ModSecurity Web Application Firewall Open source Web Application Firewall. Node.js Edge Compute Node.js Javascript application module running on Section compute edge. OpenResty Edge Compute Nginx and Lua based scriptable web platform. Radware Bot Manager Bot Management Non-human bot traffic detection and management. Signal Sciences Web Application Firewall Real-time protection for an application under attack and integrates into devops toolchains. SiteSpect A/B Testing Javascript and Tag Free A/B testing. Templarbit Shield Web Application Firewall Intelligent application protection. ThreatX Web Application Firewall Web Application Firewall based on dynamic rules. Varnish Cache Cache Latest version of Varnish Cache completely customizable. Virtual Waiting Room Traffic Management Manage user experience during extreme traffic events.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/modules/","objectID":"981b3fd62b6fde0f3f4c4ae5994db72a_0","order":0,"tags":null,"title":"Modules"},{"content":"Invite a New User via email To invite a new user to your account: Invite a New User via email Click on Account and then Manage Users in the top right of the management console. Enter the user details of the person you want to invite, and click Invite User. The invited user will receive an email inviting them to join Section and have immediate access to your account. Currently Section does not allow you to change the roles of these users, but if you want the user to have a different role (e.g. only be able to clear cache) please submit a support ticket and we will get the user\u0026rsquo;s role changed as soon as possible. The email invitation will only be valid for 48 hours.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/user-management/add-a-user-to-your-account/","objectID":"f6dcd83404594855e64ce37d856d0183_0","order":0,"tags":null,"title":"Add a user to your account"},{"content":"When you want to add a domain to Section, it is sometimes unclear where that domains should fit into your existing account, application, and environment structure. This guide will help you decide whether it is most appropriate to create a new application, create a new environment, or add a new domain to an existing environment. My new website is a staging/uat site for a production site that I have running or want to run on Section The purpose of Section\u0026rsquo;s application-environment structure is to streamline the configuration testing and promotion process for modules in your stack. With respect to configuration, the definition of an application is a git repository, and the definition of an environment is a branch within that repository. This makes testing changes to the staging environment and then promoting them to the production environment as simple as a git merge and push. If you want to add a staging site to Section, the best solution for most use cases is to add a new environment to the same application (or use the Staging environment that comes by default whenever you create a new environment). Summary: we recommend adding a new staging site to an existing application as a new environment. I want to add a new website to Section that is similar to one or more sites I already have running on Section Section maintains running containers for each module in your stack in each point of presence on a per environment basis. That means that if you assign www.example.com and www.demonstration.com to the same Section environment, the same containers will handle traffic for both sites. If you have a new site that has similar needs and configuration patterns to a site that is already running on section, then assigning both domains to the same environment greatly simplifies the overhead of managing them. When two sites have the same URI patterns for resources and routes that should and should not be cached (i.e. both are set up for HTML caching and use the same routes for admin functionality or checkout), then it often makes sense to assign both of these domains to the same environment. It is even possible to assign two domains to the same environment when the websites are running on different origin servers. Section supports routing requests to alternate origins based on the incoming request\u0026rsquo;s hostname or other criteria. If the websites are mostly the same but have a few important differences, you can manage this as well within a single configuration by building hostname specific logic into your Varnish Cache Configuration: if (req.url ~ \u0026quot;/admin\u0026quot; \u0026amp;\u0026amp; req.http.host == \u0026quot;www.example.com\u0026quot;) { // Take action A } else if (req.url ~ \u0026quot;/admin\u0026quot; \u0026amp;\u0026amp; req.http.host == \u0026quot;www.demonstration.com\u0026quot;) { // Take action B } Summary: If two websites have similar CDN/Edge compute needs, they should be mapped to the same environment. I want to add a new website that is very different from all the sites I have running on Section If you want to add a new site that has different needs from all the other sites you have running on Section, then creating a new application is often the best choice. As mentioned previously, one application corresponds to one git repository, so you will be able to manage the configuration for these two sites independently of one another. Some example use cases include: Your new site is built in a different framework or has a different architecture such that you would need to write many site specific VCL directives (if using Varnish Cache). Similar to the above, your new site is set up for a different kind of caching than your other sites. For example, site A is built for HTML caching via hole-punching, but site B caches HTML with ISE. You want to run a different module configuration on the new site — such as adding or removing a WAF or image optimizer. Note that it is possible to set up a new domain as another environment within the same application (Section supports multiple environments with names other than Staging or Production). While this allows all of your sites to share one git repository (a fact which does not particularly benefit you if the sites are different enough to not be mapped to the same environment), your sites will also share the same Kibana logs — meaning that logs from site A will be mixed in with logs from site B. Summary: If two websites have different configuration needs or require different modules to run in the stack, these two domains should be in separate applications","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/new-app-or-env/","objectID":"15c10d3a84776db117ccbc5ef83a0870_0","order":0,"tags":null,"title":"Adding a New Domain to Section"},{"content":"Each Section environment has its own overview page. The overview page displays general information about the environment\u0026rsquo;s module stack and HTTP request flow, any recent errors between Section and the origin server, and a number of links to more detailed information about the environment such as DNS information and HTTP logs. Module Stack All module stack configurations running on Section begin with the edge module (the very first module that incoming HTTP requests hit when they enter Section) and ends with the LastProxy (the last module that incoming HTTP requests pass through before leaving Section and hitting your origin server). The modules in between can be configured to perfectly suite your needs using your environment\u0026rsquo;s advanced configuration. On the overview page, we display a graphic detailing the proxies currently running in your environment\u0026rsquo;s configuration and their current order. HTTP Traffic Summary We also show you an overview graph that can be toggled between three metrics: Number of HTTP responses served per minute, Breakdown of error requests for the last hour, and Downstream response bandwidth served per minute. This data is pulled from Graphite in the Metrics view, so you can go here to dig deeper into the data. Number of HTTP responses served per minute gives you a quick sense of the overall volume of traffic hitting your website, including all HTML content and all static resources like images \u0026amp; CSS files. This view is great for a general, low-resolution picture of how your site is doing. Clicking the Error Responses button below the HTTP graph brings up a breakdown of all error responses served to your users in the last hour, separated out into 3XX (Redirections), 4XX (Client request errors) \u0026amp; 5XX (Server errors) errors. This graph provides a simple way to detect a recent increase in errors served. (#logs). Downstream response bandwidth served per minute shows you the total amount of bandwidth sent to your customers. This represents the volume of data sent, as opposed to the count (represented by the number of HTTP requests). If you see this increasing but your number of HTTP responses staying the same, then you may have increased the average size of content being requested. You can review the bandwidth by file type in Metrics to see what may be causing this increase. In addition to the overview graph, we also show data depending on whether your application is set up with Varnish or Modsecurity. Varnish For Varnish Cache we show Cache hit, pass and misses for the last hour and Upstream request bandwidth served per minute. Cache hit, pass and misses for the last hour shows the breakdown of how Varnish Cache handled your requests. The higher the hit percentage, the faster your website will perform and the less work required by your servers. Upstream request bandwidth served per minute shows the volume of data sent by the origin. The more content you cache using Varnish, the lower this will be. By lowering this number you decrease the amount of work required by your servers. Modsecurity For Modsecurity we show Intercepts, audits and passes % for the last hour and Upstream request bandwidth served per minute. Intercepts, audits and passes % for the last hour shows you the breakdown of how Modsecurity handled your requests. Intercepted means that modsecurity blocked the request (a function that must be activated in your configuration). Audits means that modsecurity looked at the request based on the rules you have turned on. Passes means that modsecurity did not look at the request. Upstream request bandwidth served per minute shows the volume of data sent by the origin. The more malicious requests you block using Modsecurity, the lower this will be. By lowering this number you decrease the amount of work required by your servers. Other Modules Depending on your configuration, you may see additional icons here for other modules such as Openresty, Kraken, or a Web Application Firewall. The overview page does not provide metrics for these additional modules like it does for Varnish and ModSecurity. To dig into metrics further for Varnish, ModSecurity, or another module in your stack, go to the Metrics tab within you r Section portal and visit our Monitoring documentation and our Debugging documentation.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/section/monitoring/","objectID":"45f11014fa8edc67f832d750a603e221_0","order":0,"tags":null,"title":"Aperture Overview"},{"content":"Overview Varnish Cache can be used to cache an API. By caching a JSON RESTFul API an application running on the edge can be made to run faster. This how-to describes using the Varnish Module on the Section platform to cache an Application Programming Interface (API). For example, an application running in a Section Node.js Module on the Edge can cache commonly used API routes in a \u0026ldquo;varnishapi\u0026rdquo; Varnish Cache Module. section.config.json The section.config.json could look like; \u0026#34;proxychain\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;varnishstatic\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;varnish:6.1.1\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;varnishhtml\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;varnish:6.1.1\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;nuxt\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;nodejs:10.11.0\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;varnishapi\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;varnish:6.1.1\u0026#34; } ], In our example we will cache the following routes; /api But, will pass all other routes to other proxies; / VCL syntax Example VCL is used in the \u0026ldquo;varnishapi\u0026rdquo; module to cache API\u0026rsquo;s. sub vcl_recv { if (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;HEAD\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;PURGE\u0026#34;) { return (pass); } #rest / soap apis or magento should pass if (req.url ~ \u0026#34;^/api/(rest|soap|v2_soap)\u0026#34;) { return(pass); } #all except /api/+ should look for cache elseif (req.url ~ \u0026#34;/api/.+\u0026#34;) { return(hash); } if (req.http.Authorization) { return (pass); } return(pass); } sub vcl_backend_response { if (bereq.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; bereq.method != \u0026#34;HEAD\u0026#34; \u0026amp;\u0026amp; bereq.method != \u0026#34;PURGE\u0026#34;) { set beresp.uncacheable = true; set beresp.ttl = 120s; return (deliver); } if (bereq.url ~ \u0026#34;/api/(rest|soap|v2_soap)\u0026#34;) { set beresp.uncacheable = true; set beresp.ttl = 120s; return (deliver); } elseif (bereq.url !~ \u0026#34;/api/.+\u0026#34;) { set beresp.uncacheable = true; set beresp.ttl = 120s; return (deliver); } if (beresp.status != 200) { # Do not cache non-200 responses set beresp.ttl = 120s; set beresp.uncacheable = true; return (deliver); } else { if (bereq.url ~ \u0026#34;^/api\u0026#34;) { unset beresp.http.Set-Cookie; set beresp.ttl = 4h; # cache for 4 hours set beresp.grace = 4h; return (deliver); } } return (deliver); } sub vcl_deliver { if (obj.hits \u0026gt; 0) { #set resp.http.section-io-cache = \u0026#34;Hit\u0026#34;; } else { #set resp.http.section-io-cache = \u0026#34;Miss\u0026#34;; } # Debug custom header if (obj.hits \u0026gt; 0) { set resp.http.CUSTOMER-API-Cache = \u0026#34;HIT\u0026#34;; } else { set resp.http.CUSTOMER-API-Cache = \u0026#34;MISS\u0026#34;; } } sub vcl_hash { # Purpose: Split cache by HTTP and HTTPS protocol. hash_data(req.http.X-Forwarded-Proto); } Replace CUSTOMER-API with a custom header i.e. Section or MyAwesomeAPP.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/api-caching/","objectID":"e00ab520723efe24fd08080c67270ea6_0","order":0,"tags":null,"title":"API Caching"},{"content":"Bare domains (sometimes called naked domains, or apex domains) present a challenge to DNS, because they do not permit the use of CNAME records at the zone apex. Your website runs on as a bare domain if you are using a name like https://example.com. Notice there is no prefix like \u0026ldquo;www.\u0026rdquo; or \u0026ldquo;shop.\u0026rdquo; before example.com. In most situations, we recommend moving off your bare domain so that your website uses a prefix. There are advantages to doing this: You\u0026rsquo;ll get better manageability of your DNS. Your security may be improved. There\u0026rsquo;s a good discussion on this topic here: https://www.yes-www.org/why-use-www/ Common Misconceptions About Moving from a Bare Domain to a Subdomain As engineers, here are some of the common questions we are faced with. My SEO people say that moving the domain will kill SEO This isn\u0026rsquo;t correct. If you redirect your bare domain traffic to a domain with a prefix (eg. HTTP redirect example.com to www.example.com) using HTTP 301 redirects, search engines will update their indexes accordingly. My marketing people say that \u0026ldquo;the brand\u0026rdquo; is the domain name without a prefix This doesn\u0026rsquo;t matter either. They can continue to use the bare domain in printed materials, and links on the Internet, without any effect on user experience, when HTTP 301 redirects are put in place. I Can\u0026rsquo;t Convince the Team, and I Really Need Bare Domains That\u0026rsquo;s fine. There are some DNS providers that allow you to fake the CNAME at the zone apex. Ask your DNS provider if they support ALIAS records. This is where the DNS provider actually does the CNAME lookup on the DNS server. So instead of responding with a CNAME record for the user to look up, they do the lookup first. They then respond with the A records. If your DNS provider doesn\u0026rsquo;t support ALIAS records, then you need to move DNS hosting. Section provides a high quality, global, anycast-based DNS service free of charge to our users. You could use our DNS hosting, or any provider that supports ALIAS records at the zone apex. If you have any questions, please ask in the Community Slack Channel. Join us at https://yxorp.section.io.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/bare-domains/","objectID":"64e1861b3ba26edf14b850dfd9b4e716_0","order":0,"tags":null,"title":"Bare Domains"},{"content":"In this document and video we get a basic demo of how to search the HTTP Logs in Section\u0026rsquo;s dashboard called Aperture. Use the Kibana 4 HTTP Logs to debug the proxy stack for possible issues with origin or the application in Section. Intro 0:00 First time setup 1:33 Basics 2:17 Filters 3:26 Manual search 5:28 Tip 1 - faster work flow 6:52 Tip 2 - CSV exporter 7:24 HTTP Logs Login to Section\u0026rsquo;s dashboard Aperture and click the HTTP Logs link. HTTP Logs Screen Open the HTTP Logs screen and view Kibana wrapped inside an iframe in Aperture. Launch HTTP Logs in Full Window Click the Open in New Window button which opens HTTP Logs Kibana screen in a full browser window. You are now in the Discover tab. It is useful to open Kibana HTTP Logs in full screen so you can copy and paste URLs for logs Adjust the time period Click the top right hand corner of the Kibana screen next to the Clock or time icon which by default is 15 minutes. Expand time period filter pane Clicking expands the time period filtering and defaults to Quick. Quick time period filters explained The Quick section has options like Today, This Week, Last Hour, Last 4 Hour etc. Section only keeps Kibana 4 HTTP Logs for the most recent 7 days. Relative time period filters explained The Relative filter pane in Kibana allows custom relative filters. i.e. 18 minutes from now, 75 minutes from now, 275 minutes from now. Absolute time period filters explained Absolute searches are useful for selecting a range of time between two dates. This can be useful for investigating a known incident. Kibana tabs: Discover, Visualize, Dashboard \u0026amp; Settings Along the top of the HTTP Logs screen to the right of the Kibana logo are 4 tabs: Discover, Visualize, Dashboard \u0026amp; Settings. Kibana Settings Click on the Kibana Settings tab and select the Indices and a log pattern. You can now see all fields in the index which we can use the make reports in the main Discover tab. Demo Search on Edge Access edge-access.log We will now do a demo search on the edge access log. The Edge Access log is the first log in the Section proxy stack and is often a useful log to investigate the interface between Section and the origin server. Select _type edge-access.log Select the edge-access.log by selecting the popular _type filter and then click on the magnifying glass icon. This adds a search filter for the edge proxy.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/basic-logging/","objectID":"ceb89c55f04479e839b4c5e3010bf899_0","order":0,"tags":null,"title":"Basic Logging"},{"content":"Once you have set up your account, you will have access to your billing portal within the Account dashboard. The Billing Portal is where you can update your card, view your invoices or cancel your account — all from one convenient interface. To navigate to the Billing Portal, first click on the \u0026ldquo;gear\u0026rdquo; icon in your menu then navigate to \u0026ldquo;Account\u0026rdquo;. Here you will find the \u0026ldquo;Visit Billing Portal\u0026rdquo; button which will take you to our hosted billing portal. You have the option to set up a unique password for your billing portal. The Billing Portal Features: My Account Update the contact information for your subscriptions or choose a password for your account Subscriptions Provides an overview of each subscription on Section. Each website you set up on your Section account will have a separate subscription so you can track billing separately for each website. You can also attach different payment methods to each website. You can also cancel individual subscriptions from this interface. Click on the \u0026ldquo;Cancel\u0026rdquo; link in the particular subscription. Statements View each statement/invoice for your account.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/user-management/billing-portal/","objectID":"356a2a49ae16bc1e60434361efac3e16_0","order":0,"tags":null,"title":"Billing Portal"},{"content":"Overview Varnish Cache allows you to create synthetic HTTP responses with the use of vcl_synth. This can be used to deliver a 403 forbidden status code. These config changes are typically made under Advanced Config -\u0026gt; varnish -\u0026gt; default.vcl for the respective branch. VCL syntax Below is an example of how to deliver a synthetic 403 response using VCL syntax 4.0. This example will deliver a 403 response if the request matches the URI path \u0026ldquo;/admin\u0026rdquo;: sub vcl_recv { if (req.url ~ \u0026#34;/admin\u0026#34;) { return (synth(803, \u0026#34;Forbidden\u0026#34;)); } } sub vcl_synth { if (resp.status == 803) { set resp.status = 403; return (deliver); } } This is just an example of how to block a request using Varnish Cache. You can utilize many different patterns to block a request. E.g. check for user agents, country codes (example below), IP addresses, etc. Blocking traffic based on GEO Region The section.io platform performs GEO region lookup at the Edge and sets a custom header section-io-geo-country that contains the ISO 3166-1 alpha-2 country code such as US for the United States, or AU for Australia. There are also a number of other header that are set which can be useful. See: https://www.section.io/docs/edge-proxy/#ip-geolocation You can then use the section-io-geo-country header to block traffic in Varnish. sub vcl_recv { if(req.http.section-io-geo-country == \u0026#34;XX\u0026#34;) { return (synth(403, \u0026#34;Forbidden\u0026#34;)); } } Replace XX with the country code to block.You can block multiple countries by using | e.g.req.http.section-io-geo-country == \u0026ldquo;XX|YY|ZZ\u0026rdquo;","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/block-a-request/","objectID":"047211675436f4185e7124db78ddb057_0","order":0,"tags":null,"title":"Block a request"},{"content":"If visitors, crawlers, or spammers are degrading the performance of your site, it may be appropriate to block these from accessing your website content. Rather than letting these requests be processed by Section and your origin server, you can block them as they enter Section. There are two approaches to Blocking IP\u0026rsquo;s. IP Restrictions screen in Aperture web dashboard section.config.json in Advanced Config \u0026amp; git workflow The simplest interface to view/edit these values is available via \u0026ldquo;Configuration\u0026rdquo; \u0026gt; \u0026ldquo;IP Restrictions\u0026rdquo;. Note that blocking an IP within Aperture as described above adds the IP to the file section.config.json behind the scenes. 1. Block IP via Aperture IP Restrictions Requests can be blocked by IP address or routing prefix. For each requesting IP you wish to block requests from, click the \u0026ldquo;Add Another\u0026rdquo; button on the page and enter the address or range that you wish to block to the \u0026ldquo;IP address/CIDR block\u0026rdquo; text box. Once complete, press the \u0026ldquo;Save\u0026rdquo; button. Within a few seconds Section will be blocking requests from your blacklist. 2. Manage your IP blacklist from within your application repository The IP blacklist is stored in the section.config.json file in the root of the git repository for your web site. You can view this by going to https://aperture.section.io/, selecting your site and then going to the \u0026ldquo;Advanced Config\u0026rdquo; page. Simple proxy stack The ip_blacklist field is applied to an environment (living at the same level as origin ). It is a list (array) of IP v4 addresses and/or CIDR notation routing prefixes. The request blacklist is specified via an ip_blacklist property inside one of the environment objects found within the section.config.json file inside your Advanced Configuration tab of Aperture — for example: { \u0026quot;proxychain\u0026quot;: [], \u0026quot;environments\u0026quot;: { \u0026quot;Production\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot; }, \u0026quot;ip_blacklist\u0026quot;: [ \u0026quot;192.0.2.1\u0026quot;, \u0026quot;198.51.100.0/24\u0026quot; ] }, \u0026quot;Development\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot; } } } } The section.config.json file blacklist accepts individual IP addresses as well as entire subnets. This configuration file would block all requests from 192.0.2.1 and from the IP range of 198.51.100.0-198.51.100.255. The origin server would never even see the requests and the Section platform would deliver 403 forbidden errors directly to the (likely malicious) clients. If you prefer, you can create a custom response to entities on the IP blacklist.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/blocking-requests/","objectID":"41644f2ecc376091f51867513e17c107_0","order":0,"tags":null,"title":"Block IP"},{"content":"Section is a proxy service, so at the end of the day, any requests for your site that have not been offloaded by the cache or redirected or blocked by the firewall will be passed on to be served by your webserver. The address of this server (or the address of the load balancer in front of your servers) is the origin address. When your first setup your site on Section we resolve the DNS of the hostname you enter and set that as the origin address. This origin address is stored in a JSON file in the root of the git repository for your application. You can view this by going to https://aperture.section.io/, selecting your site and then going to the “Advanced Config” page. This gives you a view of the git repository for your site. From there you can open section.config.json. This is the configuration file for your site on Section. It contains the proxy stack you have configured and environment specific configuration settings. Each environment has its own section in the file where you can specify config options for that environment. There are a number of possible config settings but for now the one we are interested in is origin.address. To change the address of your production environment Click the Edit button on the page. This will open the online file editor. From there you can change the value of the origin address to the new IP address or CNAME. To save the change, put a description in the Commit Message field (remember, this is all git) and click Commit. This will do a git commit \u0026amp; push which will trigger a deploy to the Section delivery nodes to apply the new origin address. Within a few seconds Section will be serving requests from your new webserver. We will direct all http requests to port 80 and all https requests to port 443 on your origin server. We do not support any other origin ports. Override the Host request header sent to the origin Normally, the same Host request header sent by the User-Agent will be forwarded to the origin server as-is. However if your origin expects a different Host request header, an override can be specified in the section.config.json file. The alternate Host request header should be specified via a host_header property inside the origin object, for example: \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;override.example.com\u0026quot; } Removal of X-Forwarded-Proto and other request headers Some origin servers and load balancers don\u0026rsquo;t handle certain request headers like X-Forwarded-Proto correctly. You can remove them by editing your section.config.json by adding a remove_request_headers key for each origin. \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;remove_request_headers\u0026quot;: [ \u0026quot;x-forwarded-proto\u0026quot; ] } Disable persistent connections between Section and the origin By default, if your origin allows HTTP/1.1 persistent connections Section will maintain a number of connections open between our reverse proxies and your origin web servers to reduce the cost of performing a TCP 3-way handshake (or more for TLS connections) for each HTTP request forwarded to the origin. This is also known as HTTP Keep-alive. While persistent connections are generally recommended for the best performance, there are occasional scenarios where you may need to disable it. For example, if you origin load balancer injects a sticky-session cookie only for the first response on a given connection because it assumes one connection equals one browser. To disable the persistent connection behavior, add a disable_keepalive property to the relevant origin in your section.config.json file. \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;disable_keepalive\u0026quot;: true } Leverage alternate origin locations A common customer requirement is to send a portion of traffic to an alternate origin location. This is often used to segment the uri space or flag a specific type of request to be sent to an alternate location to the standard origin. An examples of this use case would be to send any request to /assets/images/.* in your application to an S3 bucket instead of your origin application servers. To implement this feature there are 2 elements to configure, Please see our Alternate origin documentation here: https://www.section.io/docs/multiple-origins/ Enable SNI If your origin has SNI enabled and serves multiple secure(HTTPS) websites using different SSL certificates then you should Enable SNI under Origins \u0026gt; Common Settings in the aperture portal. This will enable our platform to pass the server name through TLS/SNI when establishing a connection with your origin. This option is turned off by default.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/change-origin/","objectID":"6593790742cc34daa731b3779af6cc51_0","order":0,"tags":null,"title":"Change your Origin Address"},{"content":"Using the command line - OpenSSL Open a terminal. Run openssl s_client -showcerts -connect www.example.com:443 \u0026lt;/dev/null, with your domain name. If successful, you\u0026rsquo;ll receive a complete output of what a browser uses to establish secure HTTP. Using an online tool - DigiCert Browse to an online certificate checking service such as: https://www.digicert.com/help Enter your domain name and initiate the check Verify your setup receives a tick at the bottom of the test","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/check-your-current-https-setup/","objectID":"a4dd4d09fc15a4d31606afe10a5e859c_0","order":0,"tags":null,"title":"Check your current HTTPS setup"},{"content":"What does it do Image optimisation module that will compress, resize, crop, transform images to suit the customer\u0026rsquo;s use case. Use Cloudinary to deliver the optimal image for every image viewing context. Deploying on-the-fly image manipulation and optimization for your website is super simple on Section. Deploy Cloudinary on Section to access all the benefits of the Cloudinary Image Optimization suite: High-performance image optimization Crop, scale, transcode, enhance images on the fly Dynamic scaling and cropping of responsive images Device recognition and image manipulation to suit Deliver faster page loads Image optimization for web is one of the most important elements of delivering faster pages. Having large image files or a high number of individual images can significantly impact load times, and unrendered images result in poor user experience. Cloudinary optimizes all common image file types by compressing them so that visitors receive images that work best with their device type and browser. Cloudinary can also resize your images on the fly and do face detection among other things. To see how Cloudinary can optimize all your images, visit the Cloudinary Documentation.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/cloudinary/","objectID":"43cc053c01ac06f4b27bfea86505bfe0_0","order":0,"tags":null,"title":"Cloudinary"},{"content":"Per GB Rates Each 1000 pages served on the Section platform includes 3GB of data. Where data used exceeds 3GB on average per 1000 pages served in any billing period, the following excess GB charges will apply: Region Rate per GB US $0.05 Europe $0.05 Singapore $0.08 Tokyo $0.12 Australia $0.12 South America $0.19","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/additional-information/commercial-terms/","objectID":"fc7955459e9d976621f6e3fbf72b2741_0","order":0,"tags":null,"title":"Commercial Terms"},{"content":"Caching is so effective at boosting website performance because delivering web content involves extreme repetition. Web servers receive requests for identical static assets and HTML documents thousands (or hundreds of thousands) of times per day. Caching allows the web server delegate this repetition to the caching layer and only respond to a small fraction of these requests. Eliminating this repetition makes your web server significantly more efficient and can drastically reduce server costs. This simple formula becomes more complicated, however, when a website introduces authenticated content. These assets are no longer identical — they have important personal information unique to the user making the request. When authentication is involved, caching becomes dangerous. The last thing you want is session leakage: a situation in which one user\u0026rsquo;s personal information is cached and served to another user. Below are two techniques that have been developed to maximize caching while avoiding the potential downfalls of dealing with authenticated content. Intelligent Session Establishment (ISE) Because of the significant risks around caching authenticated content, Varnish Cache does not cache backend responses with any set-cookie headers by default. It also does not look up responses in cache for any requests with cookies on them. The thinking here is that if a backend is responding with a set-cookie header, the response is likely to have some authenticated, user-specific content, or if a client has a cookie, then they\u0026rsquo;re asking for the same. This makes sense in theory, but the problem is that many modern web development frameworks set cookies on non-authenticated responses, greatly reducing Varnish\u0026rsquo;s caching rate out of the box. To Varnish Cache , a much higher percentage of modern web traffic looks uncacheable than actually is. Intelligent Session Establishment is a technique that solves this problem by using Varnish Cache Configuration Language (VCL) to cache and look up in cache the traffic that Varnish Cache thinks is authenticated but actually is not. In order to implement this, you need to know a few things about your platform. The first thing you need to know is the actual cookie that establishes your session. Once you know this, you can specifically instruct Varnish Cache to pass over any traffic that has or is setting this cookie, but cache ones that have or are setting other cookies. Next, you need to know what routes you want Varnish Cache to treat as uncacheable no matter what. This would be routes like \u0026lsquo;/checkout\u0026rsquo; or \u0026lsquo;/admin\u0026rsquo;. Once you have written VCL excluding these two types of requests, you can instruct Varnish Cache to cache other kinds of traffic. For more information on implementing ISE, check out this article. Hole-Punching Even though authenticated pages clearly have user-specific and therefore uncacheable personal information, they also have a lot of generic and reusable resources on them. User account pages, for example, are literally designed to display unique personal data, but they also reuse much of the same HTML and CSS for every customer. As long as we\u0026rsquo;re sending a user account page via a single response, though, we miss out on caching all this generic content. Hole-punching is a design pattern that solves this problem by loading the authenticated and unauthenticated content for a single page with different requests. To implement hole-punching for a user account page, for example, you would configure the application to respond to such a request with the generic HTML document and other reusable resources, and then load the user-specific information with additional requests — either AJAX or ESI calls (Edge Side Includes). This way, you can cache the generic content and leave the authenticated content completely alone. HTML Streaming No matter how session-specific and customized a page is, typically the head of the HTML document for a given URL is the same for every user. From a website optimization perspective, anything that is reliably the same can be cached. HTML Streaming is a technique that leverages this consistent repetition of the head tag in order to optimize delivery. With HTML streaming implemented, our platform separates out the head and body of incoming HTML documents and then caches the head portion. For all subsequent requests for that URL, Varnish Cache delivers the HTML head immediately with an embedded ESI tag which requests the body. Beyond the obvious performance benefits of caching a piece of the HTML document, HTML streaming offers extremely fast time-to-first-byte on pages that cannot be cached according to traditional methods. Summary ISE is a technique that is implemented at the Section level and allows us to cache as many valid responses as possible. Hole-punching is a design pattern implemented on your origin application that separates authenticated and unauthenticated information into separate requests to allow for maximum caching. HTML streaming offers quick time-to-first-bytes by selectively caching HTML documents. For implementation questions on any of these, contact our engineering team at support@section.io","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/dynamic-caching/","objectID":"3bea6252b24238935fd5ecbf6ba96f4c_0","order":0,"tags":null,"title":"Configure Dynamic Content Caching"},{"content":"GEO based origin selection Below is an example of how to configure your Content Delivery Grid to direct requests to different origins based on the requesting user\u0026rsquo;s GEO location. Prerequisites: Section account Section application running Varnish A separate origin with content for users of different GEO locations In your default.vcl file you can set a header that\u0026rsquo;s recognizable in Section last-proxy to determine which origin address and host header to make the request with. So you are going to need to define that origin first in your section.config.json file located in the root of your applications git repo. You will be adding a key called alternate_origins under environments.Production. section.config.json ... \u0026quot;environments\u0026quot;: { \u0026quot;Production\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.1\u0026quot; }, \u0026quot;alternate_origins\u0026quot;: { \u0026quot;US_origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.2\u0026quot; }, \u0026quot;AU_origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.3\u0026quot; } } }, ... default.vcl Next we tell Varnish Cache to use this origin for requests depending on the GEO IP country code. Use the origin names defined in section.config.json. sub vcl_recv { ... if ( req.http.section-io-geo-country-code ~ \u0026quot;(?i)^(US|CA)$\u0026quot; ) { set req.http.section-origin = \u0026quot;US_origin\u0026quot;; } elsif ( req.http.section-io-geo-country-code ~ \u0026quot;(?i)^(AU|NZ)$\u0026quot; ) { set req.http.section-origin = \u0026quot;AU_origin\u0026quot;; } ... } Note 1: Requests not from US/CA/AU/NZ will be directed at the default origin of 203.0.113.1. Note 2: If you are caching responses, make sure to hash_data(req.http.section-origin) to split the cache based on origin. Overview This use case is especially helpful if you are serving unique content to different geographic locations, such as offers only available in certain regions or pages in different languages or currencies or just to keep load separated between different origins. Section handles all the internals of actually making the request to origins for each region and all you have to do is configure your reverse proxy setup in your git repo!","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/geo-based-origin/","objectID":"39c2095d5eb5bbce9ea7bb113847a7c3_0","order":0,"tags":null,"title":"Configure GEO-based origin selection"},{"content":"Static asset origin Below is an example of how to configure your Content Delivery Grid to direct all requests for static assets to a separate origin. Prerequisites: Section account Section application running Varnish A separate origin for your static assets (e.g. S3 bucket) In your default.vcl file you can set a header that\u0026rsquo;s recognizable in Section last-proxy to determine which origin address and host header to make the request with. So you are going to need to define that origin first in your section.config.json file located in the root of your applications git repo. You will be adding a key called alternate_origins under environments.Production. section.config.json ... \u0026quot;environments\u0026quot;: { \u0026quot;Production\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.1\u0026quot; }, \u0026quot;alternate_origins\u0026quot;: { \u0026quot;assets_example_com\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.2\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;assets.example.com\u0026quot; }, } }, ... default.vcl Next we need to tell Varnish Cache when to use and how to define this origin for static assets. We will be using the name we defined in your section.config.json. sub vcl_recv { ... if (req.url ~ \u0026quot;/some-unique-url-for-static-assets\u0026quot;) { set req.http.section-origin = \u0026quot;assets_example_com\u0026quot;; } ... } Note: If your origin only accepts traffic on port 80 and you are requesting this resource over HTTPS, you will need to set the X-Forwarded-Proto to http. set req.http.X-Forwarded-Proto = \u0026quot;http\u0026quot;; Overview This use case is especially helpful if you are requesting your static assets on the same domain (e.g. www.example.com) to utilize HTTP/2, but want to take the load off your default origin when requesting static assets. Section handles all the internals of actually making the request to your assets origin and all you have to do is configure your reverse proxy setup in your git repo!","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/static-asset-origin/","objectID":"bdd0078f4d96242eca5178257e4da842_0","order":0,"tags":null,"title":"Configure static asset origin"},{"content":"Overview This guide will walk you through the steps needed to add a domain to an existing Section environment. For help understanding whether adding an new domain to an existing environment is best for your use case, please visit this guide. If you wish to set up an entirely separate application for this domain or have reached this page without following the going live tutorial please see the getting started guide for a comprehensive guide to every step of the go live process. Note as well the DNS guidelines for running multiple domains on one environment. Step 1 - Adding the domain Navigate to the DNS section of your existing Section application. Click the Add domain button and input the desired domain. Hit save. This will configure the Section platform to route all requests for your desired domain through this environment\u0026rsquo;s module stack. Step 2 - Configuring DNS You will need to make the DNS record for the domain you added point to the CNAME record automatically generated for that specific domain for traffic to flow through the Section platform. Assume we added www.example.com Navigate to your DNS hosting provider. Add a CNAME record for www.example.com The value will be www.example.com.c.section.io Save your changes. You can test these configurations by utilizing dig to perform a DNS lookup to ensure the domain is pointed to your Section record. You can also use a web based tool to perform DNS lookups. Note that the DNS change can take time to propagate based upon your old record\u0026rsquo;s TTL values. Example dig command: dig +trace www.example.com @8.8.8.8 All domains added to the Section platform will generate a unique CNAME record. This CNAME record follow the naming convention domain.c.section.io. Step 3 - SSL Certificate Follow the how to guide on provisioning an SSL certificate.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/domains-dns/configuring-a-new-domain/","objectID":"930234ed60590275ecd9a6fae497816f_0","order":0,"tags":null,"title":"Configuring a new domain"},{"content":"DIf you don\u0026rsquo;t have an Aperture account and want to use the devpop to simply test reverse proxies, feel free to skip this section.* In the upper right hand corner of the devpop UI, there is a Connect to Aperture button. When clicking this it will redirect you to Aperture and prompt you to login and authorize the devpop. If you are successful then the Connect to Aperture button will be replaced with a blinking blue icon followed by your email address. This will enable an Import button on the Operations column of the services table, which will open up a modal prompting you to select the application you want to import.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/developer-workflow/connect-to-aperture/","objectID":"f3a1a64542fded2245dc66f8a3015f98_0","order":0,"tags":null,"title":"Connect Developer PoP to Aperture"},{"content":"Get started Log into your Aperture dashboard and under Set up navigate to the HTTPS page. HTTPS in Aperture Select domain HTTPS Pulldown The SSL information for the first domain in this application will automatically load. If you have setup multiple domains on a single application, click the drop down box \u0026ldquo;Select your domain\u0026rdquo; and select the domain you wish to upload a certificate for. Provision certificate Click the \u0026ldquo;Renew certificate\u0026rdquo; button. If you previously used a custom certificate, click the \u0026ldquo;Switch to Let\u0026rsquo;s Encrypt\u0026rdquo; button. Let\u0026rsquo;s Encrypt will run validation tests over the domain then provision a new certificate once validation is complete. If you have only recently performed Go-Live (pointed DNS at Section) the validation process might require multiple attempts, as DNS propagation can take some time. So if your free certificate doesn\u0026rsquo;t provision straightaway, click the \u0026ldquo;Renew certificate\u0026rdquo; button again in a few minutes. If it still doesn\u0026rsquo;t provision after 3 or 4 attempts, contact our support team. Once the certificate has been provisioned, it will automatically renew every 3 months. AAAA DNS records Domains that use both A and AAAA records will need to remove the AAAA record before attempting to provision the certificate. This is because Section platform uses IPv4 and AAAA records are IPv6 which will be not pointing at Section platform leading to provision failure.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/create-a-free-tls-certificate-using-letsencrypt/","objectID":"35709326e08e76ab51a4b03b54992a24_0","order":0,"tags":null,"title":"Create a Free Certificate using Let's Encrypt"},{"content":"If you would like to create your free TLS certificates before you make your DNS change, you need to configure your server. For users of Nginx Obtain the CNAME record for your application. You\u0026rsquo;ll see this on the DNS menu in the Section management console. Add this block to your server\u0026rsquo;s configuration, replacing yourdomain.c.section.io with the CNAME you obtained above: location /.well-known/acme-challenge/ { proxy_set_header Host $host; proxy_pass http://yourdomain.c.section.io; } ` Click Renew Certificate on the HTTPS menu within the Section management console. For users of Apache Obtain the CNAME record for your application. You\u0026rsquo;ll see this on the DNS menu in the Section management console. Add this block to your server\u0026rsquo;s configuration, replacing yourdomain.c.section.io with the CNAME you obtained above: \u0026lt;Location \u0026quot;/.well-known/acme-challenge/\u0026quot;\u0026gt; ProxyPreserveHost On ProxyPass \u0026quot;http://yourdomain.c.section.io\u0026quot; \u0026lt;/Location\u0026gt; ` Click Renew Certificate on the HTTPS menu within the Section management console.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/create-a-letsencrypt-certificate-before-your-dns-change/","objectID":"a71201c4e41ff6e1c4394f99996dbedc_0","order":0,"tags":null,"title":"Create a Let's Encrypt Certificate Before your DNS Change"},{"content":"A Guide to logging custom information using Varnish Cache or at the Edge. To help with debugging Section allows several ways to log custom information then allow this information to be recorded and searchable in Kibana. 1) Log using HTTP response header Any section-io-tag HTTP response header received by Edge will be logged and indexed in Kibana edge-access-log documents as the section_io_tag field. This header can be set by origin or any proxy upstream of Edge. You will see it under Edge-access-log documents in Kibana as section_io_tag This is a HTTP header and is therefore visible downstream, so care should be taken with what information is presented in this header to prevent security issues. 2) Log using Varnish Cache std.log Varnish Cache 4.1+ VCL can call std.log(\u0026quot;section-io-cache-tag:CUSTOM_VALUE_HERE\u0026quot;); in sub vcl_deliver and the value specified will be indexed in Kibana varnish-ncsa-log documents as the section_io_cache_tag field. This is not a HTTP header and is therefore not visible upstream or downstream. Here is an example usage where an origin response header named origin-information is captured and logged in sub vcl_deliver then removed so it is not visible downstream: import std; sub vcl_deliver { std.log(\u0026quot;section-io-cache-tag:\u0026quot; + resp.http.origin-information); unset resp.http.origin-information; } If the value of origin-information header was Hello again! you would see following in Kibana. Note: Varnish Cache is setup to only log these custom values from sub vcl_recv and sub vcl_deliver. Logging information from other subroutines such as sub vcl_backend_response will be ignored.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/custom-logging/","objectID":"991dfd91a191754e70c4f13193d0c0b5_0","order":0,"tags":null,"title":"Custom Logging"},{"content":"Overview Section provides a range of debug-headers that are disabled by default. These headers can be enabled by sending the section-debug header set to any value. Section provides the following debug headers : section-origin-status section-origin-failure section-origin-dns-failure section-origin-time-seconds section-origin-status When no bytes are received from the origin web server (e.g. DNS failures) s​ection-origin-status header is set to \u0026ldquo;000\u0026rdquo;. When a response is received from the origin web server section-origin-status is set to upstream status when the upstream-status is a single status code and the last value when the upstream-status is an array of response codes (e.g. due to retries) section-origin-failure When no bytes/response is received from the origin web server and Section can resolve the DNS for the origin web server (a request to the origin is made) section-origin-failure header is set to true else it is not set. section-origin-dns-failure When Section is unable to resolve the DNS of the origin web server section-origin-dns-failure header is set to true else it is set to false. section-origin-time-seconds This header indicates in seconds the time taken by the Section platform to receive the entire response from the origin web server.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/debug-headers/","objectID":"c8b5d2566643771ed3bb2aabc8ae358a_0","order":0,"tags":null,"title":"Debug Headers"},{"content":"Overview When investigating a website slowdown, you first want to determine whether the slowdown is originating within the Section platform or at the origin server. The following guide will help you create a visualization of website performance data. Step 1 - Creating the visualization Visit your Section portal and view the HTTP Logs section of your application. This will open up the Kibana view in it\u0026rsquo;s default state. Proceed to click the visualize tab in the upper nav bar which will prompt you to Create a visualization. Select the Line Chart option followed by From a new search. The Kibana view can be opened up in a new tab by clicking the \u0026ldquo;Open in a new window\u0026rdquo; button. This is useful if you wish to share the visualization with a colleague. Step 2 - Defining the X-Axis You will now configure the X-Axis to display the data over a period of time. On the left hand side of the screen you will want to select X-Axis under the Select buckets type drop down. Select Date Histogram as the Aggregation. Hit the green play button to view the results. Step 3 - Defining the Y-Axis You will now configure the Y-Axis to display the average time taken in milliseconds for the edge logs. On the left hand side of the screen you will want to select Y-Axis under the metrics section. Configure the Aggregation to show the Average value instead of Count and this will prompt you to select a field. Here select the time_taken_ms option. Hit the green play button again to view the results of the average time_taken_ms for ALL logs. Step 4 - Splitting the lines You are now viewing the average time_taken_ms value over your selected time frame for all logs. Next steps will be to split the lines by log type to pinpoint the cause of the slowdown. On the left hand nav under the X-Axis configuration click the Add sub-buckets option. Select the Split Lines option which will add a second layer to the X-Axis. In the Sub Aggregation option box select the terms option. This will prompt you to select another field, this time you will select the _type field. Above the Sub Aggregation select box, there is an arrow which allows you to make this aggregation the main aggregate. Select the up arrow. Hit the green play button again to view the results of the average time_taken_ms for each module type. Here is an example of the finished product with clear increases in LastProxy access log times. This is a strong indicator for a slowdown at the origin application: Next Steps: If you see a pattern of clear increases in LastProxy time_taken_ms values that resembles the above screenshot, the slowdown is likely being caused by the origin server and not Section. From here, look into origin server logs and an origin server monitoring solution such as New Relic if available. If the above investigation reveals increased time_taken_ms values for Edge, Varnish Cache, or another module in your stack but a stable LastProxy value, this could indicate an degradation of service within the Section platform. In this case email support@section.io to immediately receive support from an engineer. ​","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/debug-slow-website/","objectID":"075ecf4360ca0c33118f78a979e2bf9f_0","order":0,"tags":null,"title":"Debugging a slow website"},{"content":"- www.example.com/admin/ - the admin-only site - www.example.com/assets/ - static assets - www.example.com/assets/images/ - static images only See the Split option under Overview for your application in Section Aperture for some more detail. A split application can later be [deleted](#deleting-applications) and requests for its URL prefix will resume being handled by the original application. All applications handling requests for a given domain must be within the same Section account. -- Sometimes you may wish to start an application from scratch or simply remove an unused application. 1) Navigate to application\u0026rsquo;s Overview Page Click on Actions, then select Delete Application from the drop down menu. Note, if your site is currently live on the Section platform you may wish to point the DNS record for the site away from us before deletion, as deleting the application will cause an outage until you create a new one to replace it. You will then need to confirm this action by typing in the full name for the application.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/deleting-an-app/","objectID":"12e35b2f1d8741df7fc65a5d2f21785e_0","order":0,"tags":null,"title":"Deleting an Application"},{"content":"At this time, it is not possible to delete an environment.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/deleting-an-environment/","objectID":"46ebb6eeaaf2ff6451678c050b3cf96c_0","order":0,"tags":null,"title":"Deleting an Environment"},{"content":"Overview Varnish Cache allows you to create synthetic HTTP responses with the use of vcl_synth. This is useful when you want to perform a redirect, deliver a 404, a custom error page, etc. Synthetic Responses Below is a basic example of how to deliver a synthetic response using VCL syntax 4.0. This example will deliver a 200 response with the body content \u0026ldquo;Hello World\u0026rdquo; if a request matches the URI path \u0026ldquo;/hello\u0026rdquo; sub vcl_recv { if (req.url ~ \u0026#34;/hello\u0026#34;) { return (synth(800, \u0026#34;Hello World\u0026#34;)); } } sub vcl_synth { if (resp.status == 800) { set resp.status = 200; set resp.http.Content-Type = \u0026#34;text/html; charset=utf-8\u0026#34;; synthetic(\u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;); return (deliver); } } Other use cases Redirect a request Generate a 404 response Block a request","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/deliver-a-synthetic-response/","objectID":"4409ce99afeaa4d361b65c3bb08a9573_0","order":0,"tags":null,"title":"Deliver a synthetic response"},{"content":"Getting started Download or unzip the certificates in to a directory somewhere on your computer. The certificates should be PEM encoded and will look like the following in a text editor. -----BEGIN CERTIFICATE----- /* contents of certificate */ -----END CERTIFICATE----- You will require Openssl to be installed. To check if you have Openssl installed, open a command prompt and type: openssl version You should see output like OpenSSL 1.0.2l 25 May 2017 In your command prompt go to the directory where you placed the certificates. Determine domain certificate You will need to determine which certificate is the one issued to your site(s). Run the following command in your command prompt window where certificate1.pem is the file name of a certificate you are testing: openssl x509 -noout -subject -in certificate1.pem If the certificate is the site certificate, you will see the domain of your site in the output. e.g. subject= /CN=www.yoursite.com If your domain is listed as a Subject Alternate Name(SAN) on a certificate you won\u0026rsquo;t see it under subject using the above method. You will need to examine the rest of the certificate. For linux/mac based command prompt, run: openssl x509 -text -noout -in certificate1.pem | grep \u0026quot;DNS\u0026quot; For windows based command prompt, run: openssl x509 -text -noout -in certificate1.pem | findstr \u0026quot;DNS\u0026quot; You should see a list of SAN domains on that certificate. If that list contains your domain name, then this certificate is your domain certificate. Determine intermediate certificate order Each certificate contains information about its issuer. The issuer is the next link in the SSL chain. The SSL chain will be domain certificate -\u0026gt; intermediate ceritificate(s) -\u0026gt; root certificate Determine the intermediate certificate of your domain certificate by examining the issuer of your domain cert with the following command. openssl x509 -noout -issuer -in certificate1.pem You should see output such as issuer= /C=US/O=Let's Encrypt/CN=Let's Encrypt Authority X3 Then you can compare this against the subject of the other certificate files to find one that matches the issuer above. openssl x509 -noout -subject -in certificate2.pem If this is the correct intermediate certificate, you will see a matching subject to the issuer of the domain certificate. subject= /C=US/O=Let's Encrypt/CN=Let's Encrypt Authority X3 This is your first intermediate certificate. So the certificate chain so far is certificate1.pem -\u0026gt; certificate2.pem. Now look at the issuer of certificate2.pem openssl x509 -noout -issuer -in certificate2.pem If this is the only intermediate certificate in the chain, the issuer will result in a Root issuer e.g. issuer= /O=Digital Signature Trust Co./CN=DST Root CA X3. If you don\u0026rsquo;t see an issuer that contains \u0026ldquo;Root CA\u0026rdquo; then there is likely another intermediate certificate. Examine the issuer of each certificate you have and match it with the subject of the next intermediate certificate until you see the issuer is a Root CA. This resulting order is your SSL chain.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/determine-tls-certificate-order/","objectID":"2a9d4033d3ed0aa6e81bd1f88f3bedc5_0","order":0,"tags":null,"title":"Determine TLS Certificate Order"},{"content":"Device based origin selection Below is an example of how to configure your Content Delivery Grid to direct requests to different origins based on the requesting user\u0026rsquo;s device type. Prerequisites: Section account Section application running Varnish A separate origin with content for different devices In your default.vcl file you can set a header that\u0026rsquo;s recognizable in Section last-proxy to determine which origin address and host header to make the request with. So you are going to need to define that origin first in your section.config.json file located in the root of your applications git repo. You will be adding a key called alternate_origins under environments.Production. section.config.json ... \u0026quot;environments\u0026quot;: { \u0026quot;Production\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.1\u0026quot; }, \u0026quot;alternate_origins\u0026quot;: { \u0026quot;mobile_device\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;203.0.113.2\u0026quot; } } }, ... default.vcl Next we tell Varnish Cache to use this origin for requests if we detect the User-Agent as a mobile device. Use the origin names defined in section.config.json. sub devicedetect { # The VCL here is just an example, it is not a exhaustive device detection logic. if (req.http.User-Agent ~ \u0026quot;(?i)samsung|iphone|ipod|pixel\u0026quot;) { set req.http.device-type = \u0026quot;mobile\u0026quot;; } } sub vcl_recv { ... call devicedetect; if ( req.http.device-type == \u0026quot;mobile\u0026quot; ) { set req.http.section-origin = \u0026quot;mobile_device\u0026quot;; } ... } Note 1: Requests from non-mobile devices will be directed at the default origin of 203.0.113.1. Note 2: If you are caching responses, make sure to hash_data(req.http.section-origin) to split the cache based on origin. Overview This use case is especially helpful if you are serving unique content to different devices or just to keep load off your default origin when the request is from a mobile device. Section handles all the internals of actually making the request to your mobile_device origin and all you have to do is configure your reverse proxy setup in your git repo!","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/device-based-origin/","objectID":"54a7eeb65e2c46ea4243f85f184b2089_0","order":0,"tags":null,"title":"Device based origin selection"},{"content":"The Section platform will only accept requests with a domain name that is explicitly added to an environment. For example, if you add www.example.com to Section as www.example.com but then choose to create a blog.example.com CNAME record pointing at www.example.com.c.section.io., visitors to http://blog.example.com will receive an error page displaying HTTP 409 Conflict. This is because blog.example.com has not been explicitly associated with a Section environment.In this case you would need to add blog.example.com to a Section environment and then create a blog.example.com.c.section.io CNAME record for blog.example.com in your DNS hosting console. The same is true if you register a bare domain record such as example.com. Each domain must be specified in full in order for the request to be accepted by Section. If you would like your Section application to respond to multiple domains, you can add them on bottom of the the Domains page under Domains. You can also add or delete additional domains via our API by using the following commands: POST /account/{accountId}/application/{applicationId}/environment/{environmentName}/domain/{hostName} DELETE /account/{accountId}/application/{applicationId}/environment/{environmentName}/domain/{hostName} Please review our HTTPS setup page to ensure all of your domains are properly covered by either our automated HTTPS or your own custom certificates to prevent certificate errors. If the additional domain names should redirect to the canonical domain name to improve search engine ranking, this can be achieved with a basic Varnish Cache configuration, for example: vcl 4.0; sub vcl_recv { return (synth(700, \u0026quot;\u0026quot;)); } sub vcl_synth { if (resp.status == 700) { set resp.status = 302; # or 301 if preferred set resp.http.Location = \u0026quot;https://canonical-domain.example.com\u0026quot; + req.url; return(deliver); } }","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/dns-with-multiple-domains/","objectID":"1a953e2b00383bfbab68fc870bf75a08_0","order":0,"tags":null,"title":"DNS with multiple domains"},{"content":"Ingress / Edge Proxy Every Section application proxy stack implicitly begins with the Edge proxy. The Edge proxy is the endpoint to which the User-Agent (eg web browser) connects and it has a few responsibilities: Performing the TLS handshake for HTTPS connections Routing requests to the corresponding application proxy stack Implementing the HTTP/2 protocol Request correlation Serving custom error pages This enables a consistent experience on the Section platform regardless of which proxies are in your application\u0026rsquo;s stack or in which sequence they appear. IP geolocation For each incoming request, the Edge proxy attempts to resolve the client\u0026rsquo;s connecting IP address to a geographic location. The results of the lookup are then exposed to the other proxies in the proxy stack and to the origin web server as HTTP request headers. These headers are: section-io-geo-country-code - the ISO 3166-1 alpha-2 country code such as US for the United States, or AU for Australia. section-io-geo-country-name - the country name such as United States or Australia. section-io-geo-country - the country code such as AU. section-io-geo-region - the region name such as Western Australia. section-io-geo-asn - ASN number 64098. section-io-geo-region-code - examples include CA and VA for US IPs or NSW for Australian IPs. section-io-geo-region-name - examples include California and Virginia for US IPs or New South Wales for Australian IPs. section-io-geo-city - examples include New York, Mountain View, Sydney, and Drummoyne. section-io-geo-latlon - the approximate latitude and longitude in the format -33.8696,151.2099. section-io-geo-postal-code - examples include 2047 for Drummoyne, NSW, Australia and 80302 for Boulder, CO, USA. section-io-geo-dma-code - The Nielsen Designated Market Area ID as used by DoubleClick. Only for US IPs. Not all headers are populated for all IP addresses. The latitude, longitude, country code, and city values are also available in the access logs. Client IP Detection Historically, Section has logged a header called remote_addr that contained the connecting client\u0026rsquo;s IP address. Due to GDPR compliance, however, the value of the address' last segment is now redacted and replaced with a zero. Despite this change, Section still captures the connecting client\u0026rsquo;s IP address and sends it upstream under a header called True-Client-IP. This header is not logged by our platform (and therefore is not visible in Kibana), but can be referenced within any proxy in your stack (varnish, pagespeed, etc.) and is visible to your origin server. True-Client-IP is the same IP address used for the IP geolocation. This request header can be used in a number of ways: Fraud detection IP Whitelist/Blacklisting, including restricting access to particular urls. Logging client usage Rate limiting Section also sets the X-Forwarded-For header if you need to use that, however this header will often be a list of IP addresses depending on how the request has been proxied prior to arriving at Section and is not always reliable. Request correlation When the Edge proxy handles each incoming request, a unique identifier is generated and is added to the request via a section-io-id HTTP request header. This request header then propagates through to each proxy in your application\u0026rsquo;s proxy stack and ultimately to your application\u0026rsquo;s configured origin web server. When the final response is returned from your application, via the proxy stack, to the User-Agent, the Edge proxy also inserts the same identifier as a section-io-id HTTP response header. The section-io-id value is available in all the proxy logs provided by Aperture to enable easy correlation of log entries across the different proxies in the stack. You can also choose to log the section-io-id request header on your origin server to aid with diagnostics. By providing the identifier as a request header, its value can be consumed in your chosen proxies. For example, Varnish Cache can refer to req.http.section-io-id in the VCL. The format of the section-io-id identifier is subject to change without notice so it should be treated as an opaque string and no meaning should be inferred from its value. Content compresssion By default Section will gzip responses to requests that can be compressed. This is typically text content like HTML, CSS \u0026amp; Javascript files. We will enable this compression even if your origin server does not send gzipped responses to improve performance for your site\u0026rsquo;s visitors. In the unlikely scenario that compression causes issues for your site, you can disable this feature in Advanced Configuration. Edit the section.config.json and add \u0026quot;maintain_upstream_content_encoding\u0026quot;: true to the environment you want to disable gzip encoding on. \u0026quot;environments\u0026quot;: { \u0026quot;Production\u0026quot;: { \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;override.example.com\u0026quot; }, \u0026quot;maintain_upstream_content_encoding\u0026quot;: true } } Commit this change and all responses will retain the content-encoding that is sent from the origin. Table of contents","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/edge-proxy/","objectID":"3f47b78d655e1ba5278e4b0246f6c49c_0","order":0,"tags":null,"title":"Edge Proxy"},{"content":"In addition to a strong password, your account can be further protected by enabling Two Factor Authentication. To enable two factor authentication: Click on the user icon in the top right corner of the management console and click Profile. If you want to use SMS verification: Ensure your phone number is correct Turn on two factor authentication and choose Receive an SMS on each login If you want to use an authenticator app, like Google Authenticator or LastPass Authenticator: Turn on two factor authentication and choose Store my code on a device Finally, for both options, click Save. Upon enabling 2FA, it is immediately active for all future logins. If you contact Section support we can enforce 2FA to be required for all users invited to your account.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/user-management/enable-two-factor-authentication-on-your-account/","objectID":"ececc87e070bd3baff477543dd3d784f_0","order":0,"tags":null,"title":"Enable Two Factor Authentication on Your Account"},{"content":"Requests to particular URLs can be excluded from Varnish cache. Exclude a particular URL Use the following code snippet to exclude an exact match to a URL. This code is for VCL4.0. sub vcl_recv { if (req.url == \u0026quot;/example.html\u0026quot;) { return(pass); } } sub vcl_backend_response { if (bereq.url == \u0026quot;/example.html\u0026quot;) { set beresp.uncacheable = true; set beresp.ttl = 120s; return(deliver); } } Exclude a URL pattern You can also use regex expressions to exclude URLs based on a pattern. The following code block will match any request URL that contains /URL_path/. sub vcl_recv { if (req.url ~ \u0026quot;/URL_path/\u0026quot;) { return(pass); } } sub vcl_backend_response { if (bereq.url ~ \u0026quot;/URL_path/\u0026quot;) { set beresp.uncacheable = true; set beresp.ttl = 120s; return(deliver); } }","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/exclude-url-from-cache/","objectID":"fd0564d7a228a68be1d694505a0d9f1f_0","order":0,"tags":null,"title":"Exclude URL from Varnish cache"},{"content":"Extract domain based metrics In addition to standard platform metrics you can enable domain based metrics extraction. Email support@section.io to have this enabled on your account. Once enabled this will allow you to connect to a metrics endpoint to extract data. (Interesting fact: The endpoint is a prometheus source, you could federate this and point your own prometheus infrastructure at this location) Data available This endpoint provides the following data: HTTP Requests and Bytes used by Account HTTP Requests and Bytes used by Application HTTP Requests and Bytes used by Environment HTTP Requests and Bytes used by Module (Not normally needed) Process to extract domain based metrics When logged into Section Console you can browse to the following uri (Replace ACCOUNTID with your own account ID): https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query_range Metrics names available: section_http_bytes_rate:by_module_name_and_hostname section_http_count_rate:by_module_name_and_hostname Labels: section_io_account_id section_io_application_id section_io_environment_id section_io_module_name “private-ingress” This is the first customer visible layer that incoming clients (eg browsers) connect to, Use this when looking for usage totals “varnish” Metrics from a module in the stack named “varnish” which is commonly the caching layer (may or may not be included in a customers configuration) hostname Domain name of the incoming client Example queries: All data for Account: https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query_range?query=section_http_request_count_rate%3Aby_module_name_and_hostname%7Bsection_io_module_name%3D%22private-ingress%22%2C%20section_io_account_id%3D%221949%22%7D*60\u0026amp;start=1595446578.479\u0026amp;end=1595468178.479\u0026amp;step=60\u0026amp;_=1595467942570 Restrict to specific domain: https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query_range?query=section_http_request_count_rate%3Aby_module_name_and_hostname%7Bsection_io_module_name%3D%22private-ingress%22%2C%20section_io_application_id%3D%227210%22%2C%20hostname%3D%22www.example.com%22%7D*60\u0026amp;start=1595461225.853\u0026amp;end=1595468425.853\u0026amp;step=60\u0026amp;_=1595467942575 Examples with curl: When using curl / remote systems ensure you had created a username and password in the Section Account that you are querying and included this in the uri as per below: curl -g --user username:password “https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query_range?query=section_http_request_count_rate%3Aby_module_name_and_hostname%7Bsection_io_module_name%3D%22private-ingress%22%2C%20section_io_account_id%3D%221949%22%7D*60\u0026amp;start=1595446578.479\u0026amp;end=1595468178.479\u0026amp;step=60\u0026amp;_=1595467942570” Summarise all data for the last 24hrs for a specific domain: curl -g --user username:password \u0026quot;https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query_range?query=sum(sum_over_time(section_http_request_count_rate%3Aby_module_name_and_hostname%7Bhostname%3D%22www.example.com%22%2Csection_io_account_id%3D%22ACCOUNTID%22%2Csection_io_module_name%3D%22private-ingress%22%7D%5B86400s%5D))*(60)\u0026amp;start=1601437080.527\u0026amp;end=1601523480.527\u0026amp;step=86400\u0026amp;_=1601509374478\u0026quot; Query API is also available: https://aperture.section.io/account/ACCOUNTID/prometheus/api/v1/query?query=section_http_request_count_rate%3Aby_module_name_and_hostname%7Bsection_io_module_name%3D%22private-ingress%22%2C%20section_io_application_id%3D%227210%22%2C%20hostname%3D%22www.example.com%22%7D*60 Notes: The step function you specify has impacts on how fast (or slow) your query will respond. Follow these guidelines: Never make step less than 60 seconds as this will not increase granularity of results If pulling a 60 second step don\u0026rsquo;t request more than 2-3hrs of data If pulling 24hr usage try a step of 1hr of more Expect 7 days of metric retention","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/monitoring/extract-domain-based-metrics/","objectID":"967d4fe6a1cb926f5f37adbe8b92bb02_0","order":0,"tags":null,"title":"Extract domain based metrics"},{"content":"Overview If you with to filter your HTTP Logs by a particular URI path, you\u0026rsquo;ll first need to open up Kibana located under the HTTP Logs section for your application. Accessing logs You\u0026rsquo;ll first want to start out by searching for the URI path in the search bar by using the following syntax: uri_path:\u0026quot;/some/uri/path\u0026quot; Note: do not include any query strings This is bring up a list of all logs where that URI path strictly equals the value to searched for. To analyse the results you can do a few of the following: Add the _type field as a column to view the different types of logs. E.g. edge-access-log, varnish-ncsa-log, or last_proxy-access-log. Add the status filed as a column to see the status code each module delivered downstream.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/filter-http-logs-by-uri-path/","objectID":"097a3ad48f91d0c44cdb5ecb68e6721a_0","order":0,"tags":null,"title":"Filter HTTP logs by URI path"},{"content":"Overview Varnish Cache allows you to create synthetic HTTP responses with the use of vcl_synth. This can be used to deliver a 404 not found or 410 permanently removed status code for a particular asset. VCL syntax Below is an example of how to deliver a synthetic 404 response using VCL syntax 4.0. This example will deliver a 404 response if the request matches the URI path \u0026ldquo;/hello.jpg\u0026rdquo; sub vcl_recv { if (req.url ~ \u0026#34;/hello.jpg\u0026#34;) { return (synth(804, \u0026#34;Not Found\u0026#34;)); } } sub vcl_synth { if (resp.status == 804) { set resp.status = 404; return (deliver); } } Note: You can use 410 instead of 404 to deliver a HTTP 410","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/respond-with-a-404/","objectID":"13cbe0066d3d8908ed96913bf1e2b881_0","order":0,"tags":null,"title":"Generate a 404 response"},{"content":"Section platform has a default built-in HTTP health check that monitors the health of the environment across multiple locations in the world. Section uses a health check that queries the path /.well-known/section-io/aee-hc/healthz?ts=\u0026lt;timestamp\u0026gt; to check for health of the entire stack of modules and it\u0026rsquo;s ability to handle HTTP traffic. Section uses multiple remote-agents throughout the world to query the environment and then the individiual health responses are aggregated. An individual health response is calculated according to the following conditions : Scenario Healthy error: timeout irrelevant error: dns irrelevant error: tls, note: that this does not validate the certificate false Anything other than a HTTP 200 OK from the Remote Agent irrelevant headers contains section-origin-status and the value is not 000 and not empty true status: 409 and headers contains section-ingress: not-configured false status: 5\u0026ndash; where \u0026ndash; is any number false status is any number and does not meet the above conditions true You can read more about custom debugging headers here. Example You can use the following example to query your environment and confirm if your environment is healthy to handle HTTP traffic : curl --head \u0026#39;https://apps.manibatra.xyz/.well-known/section-io/aee-hc/healthz?ts=12345\u0026#39; \\ --header \u0026#39;section-debug: true\u0026#39; \\ --max-time 30 HTTP/2 404 date: Tue, 27 Apr 2021 04:53:20 GMT content-type: text/html content-length: 6118 vary: Accept-Encoding vary: Accept-Encoding etag: \u0026#34;60878fc3-17e6\u0026#34; section-origin-dns-failure: false section-origin-status: 404 section-origin-time-seconds: 0.271 section-io-id: 51a17b0c4b0f233e711ad1a1b256c2fd In the above example we query an environment with the hostname apps.manibatra.xyz. The above response is deemed healthy according to the conditions mentioned above.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/health-check/","objectID":"9186f1e5a1f7241d942a119646183770_0","order":0,"tags":null,"title":"Health Checks"},{"content":"There are three ways to remove objects from the Varnish Cache : Clear the cache by a particular url. Clearing the entire cache. Fine tuned control of the cache with Varnish Cache ban expressions. Clear a particular URL You can remove particular URLs from the cache by entering the URL and clicking Purge. This form accepts wildcards in the form of *, so entering /images* will purge all URLs starting with /images. You can also clear the cache for a specific URL, for example https://www.example.com/assets/css/styles.css. Empty the entire cache This will remove everything from the cache. Use this if the cache is completely out of date and it needs to be refreshed. NOTE: This may cause increased load on your origin server and also slow down your website for users until we are able to refill the cache. Varnish Cache ban expressions You can think of bans as a way to purge or filter out object that are already in the cache. Keep in mind that this method does not ban future requests from being stored in the cache. Support for bans are built into Varnish Cache so to learn how to use bans, see the Varnish Cache documentation.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/clearing-the-cache/","objectID":"cf46577184afb485fa39fe6807fbe75c_0","order":0,"tags":null,"title":"How to clear the cache"},{"content":"From the management console, click API in the top menu. This will bring you to a UI for all our API routes grouped by category. Scroll through the list, Click Show/Hide on the Proxy group, then click on the POST method ending with state. Here, you\u0026rsquo;ll see an interface to help build your API call. Enter your account id, application id, environment name, and proxy name.These can be obtained from the URL in the management console (go to your aperture homepage and look at the URL - the numbers go accountId -\u0026gt; applicationId -\u0026gt; environmentId). Your proxy name is probably varnish, but you can also clear cache for other caching proxies. Click Run. Now, you\u0026rsquo;ll see a generated request/response cycle for your cache-clear. Pay attention to the response, and notice that the varnish ban expression is appended to the end of the URL as a query string. From here, you can start making automated cache clearing API calls from within your system! Note that these API requests are authenticated using HTTP basic auth and your aperture credentials. To replicate the API calls made from Swagger outside of the portal, simply add \u0026ndash;user user@example.com:your_password.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/clearing-the-cache-using-the-api/","objectID":"e7284fd8729baace5253bf7af1ce2812_0","order":0,"tags":null,"title":"How to clear the cache using the API"},{"content":"Have a look in Chrome\u0026rsquo;s development tools, on the network tab, to discover the HTTP response code for a request. HTTP 522 This is a modified HTTP 502 status code and means that we had trouble establishing a TCP connection to your server. Here are some things to check: Is your server running? Sometimes your web server (for example, Apache or nginx) may not be running. It may be refusing TCP connections. Is your origin server address correct? Try browsing directly to your server IP (you may need to override DNS with hosts file entries). If not, update your origin address. HTTP 524 This is a modified HTTP 504 status code and means your application took too long to respond. Here are some things to check: Is your server under heavy load? Perhaps you could improve your cache hit rate. HTTP 508 The HTTP status code that Section edge serves if there appears to be a cyclic loop (i.e., egress requests back to edge). Here are some things to check: Is your origin configured as another environment on the Section platform? Custom Error Messages If you would like to customise what HTML we return in case of specific HTTP error codes you can place a file in the custom_errors folder in your application repository. The repository is initialized with a custom_errors folder containing a 500.html.sample file. To customise the HTML returned in case of a 500 error the file should be renamed to 500.html and the HTML inside customized to what they want. Other error codes can be implemented in the same way, eg. 503.html, 404.html, etc. Customising error pages for 502 and 504 errors will also customise error pages for 522 and 524 error codes. Only valid nginx error codes can be used, that is codes between 300 and 599 excluding 499. Any other files in that folder will be ignored.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/http-error-messages/","objectID":"8464e5ca6b8f45263b9bca0f5356fdac_0","order":0,"tags":null,"title":"HTTP Error Messages"},{"content":"The Varnish Cache project provides some high level instructions on improving cache hit rate. The following describes the work flow with Section metrics and development processes to achieve optimal cache hit ratios. Review Section Varnish Cache metrics Review http logs Make changes to VCL locally Confirm change has been effective -\u0026gt; Logs Promote changes to Production Confirm change has been effective -\u0026gt; Metrics Rinse and repeat Review Varnish Cache Metrics Your Section Varnish Cache metrics provide an overview of cache hit ratios for all asset types in addition to cache hit ratios by type. You can use these metrics to identify an object type for which you would like the cache hit ratio to be improved. Review HTTP Logs Use the Kibana logs to review the HTTP requests. For more information about these logs please check out the docs here. Make Changes to VCL Modify your local VCL file. Save and fire the requests at your local instance. See Local Development. Review logs again to confirm a change in the cache hit behavior for the target assets. Promote Changes to Production If required you can test the application locally to confirm the VCL changes have not affected the functionality of the application adversely for users. Sync your Section repo with production and confirm cache hit rates are improving by reviewing your metrics. Rinse and Repeat Until you hit a desirable cache hit rate across the site. Completed all 7 steps? Awesome! Steps 5 through 7 are meant to be an iterative process. Focus on big wins first using your metrics evaluation. Then after you’ve improved those areas, you can focus on other areas to fine tune. How do I know if I’ve been successful? You have improved your Cache Hit Rate You have ensured your most requested content is being cached You have increased the ratio of HTTPS on your site Because you’ve achieved these three goals, you see your customers bouncing less frequently and viewing more pages on your website - which will translate into more revenue for you! Congrats! Need Help? Section is here to help with setup and can be reached by emailing contact@Section. If you want help with configuration you can ask us about consulting engagements, and if you want a fully managed service please contact us for a quote.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/varnish-cache-hit-rate/","objectID":"93fb11ddcf55b74b4f9b7fc75c7794ff_0","order":0,"tags":null,"title":"Improve Varnish Cache Hit Rate"},{"content":"The section.config.json file The config files dictates the order that traffic will flow through the proxy chain — be aware of the location you put the new reverse proxy in. For example, if your application is setup with Varnish Cache 4.0.3, you should see this at the top of your config file: \u0026quot;proxychain\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;modsecurity\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;modsecurity:2.2.7\u0026quot; } ] 1) Add the proxy to your environment\u0026rsquo;s section.config.json file Let\u0026rsquo;s add Varnish Cache 6.0.0 to the example above. You can find a list of current proxies here To add a proxy, we need to insert a json object containing the proxy\u0026rsquo;s name and image (the specific version of the proxy you want). After adding the Varnish Cache proxy, our file looks like: \u0026quot;proxychain\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;modsecurity\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;modsecurity:2.2.7\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;varnish\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;varnish:6.0.0\u0026quot; } ], Note that different proxies have different ways of specifying the image. 2) Deploy your new configuration Section has a git-ops workflow. Deployment is via git commits. Free and open source proxy Modules like Varnish do not require Section engineers. However, paid proxies like Kraken or ThreatX require Section engineering initialization and setup at the beginning of a proxy life-cycle. After initial setup, normal git-ops will trigger deployment of changes to environments such as Production or Staging. If you need to contact a Section engineer please send us a support ticket.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/install-a-new-proxy/","objectID":"623391a130d3b645dbfa35fcfe87c771_0","order":0,"tags":null,"title":"Install A New Proxy"},{"content":"Section has an extension for Magento customers that allows business managers to access Section site metrics. These metrics provide visibility into the impact caching has on your website, without having to login to the Section application. You can get the extension for your Magento website by going to the Magento Marketplace. There are three metrics we show in the extension: Overall Cache Hit, HTML Cache Hit, and HTTP Response Codes. The extension in Magento is meant to give you an overview on the current status, but by having a developer look into your Varnish Cache configuration settings or your logs in the in the Section application, you can improve all of these metrics. Overall Cache Hit Overall Cache Hit count shows the number of cache hits from all content types. A cache hit is when a customer requests content from your site (whether it\u0026rsquo;s an image, html document, etc) and the cache is able to respond to that request. The chart shows successful responses (responses with a 200 HTTP response code) in 4 hour increments over the previous 7 days. The timezone is based on the location of the Magento user. The more often the cache can answer your customer requests, the higher the overall cache hit count. The higher the number of cache hits, the faster your website loads and the less work is required by your servers. This means you can earn more revenue by providing a better experience for your customers, and you can save money by not having to purchase additional servers with Magento. You can increase the overall cache hit count by caching more content. To setup caching, login to Section aperture account and add configurations for Varnish. HTML Cache Hit HTML Cache Hit count shows the number of cache hits for HTML documents. HTML documents are a set of instructions used to create the webpage and determine how all other content types get loaded on the page. The chart shows successful responses (responses with a 200 HTTP response code) in 4 hour increments over the previous 7 days. The timezone is based on the location of the Magento user. As with overall cache hit, the more often the cache can answer requests for the HTML document, the higher the HTML cache hit count. The higher the number of HTML cache hits, the faster your website loads and the less work is required by your servers. HTML documents are generated for you by Magento and they consume a significant amount of your server resources. By focusing on HTML document caching as the first type of content you try to optimize, you are focusing on the content type that can make the biggest initial improvement to both your performance and server resources. This means you can earn more revenue by providing a better experience for your customers, and you can save money by not having to purchase additional servers with Magento. To increase the HTML cache hit count, you should start serving these documents from the cache instead of from your server. To setup caching, login to Section aperture account and add configurations for Varnish. HTTP Status Codes HTTP status codes show how your website responded to a customer request. The extension in Magento is meant to give you an overview, but we recommend that a developer look into the logs in the Section application in order to review the codes as described below in order to make improvements. The chart shows responses by type in 4 hour increments over the previous 7 days. The timezone is based on the location of the Magento user. Here is what each of the response types mean and what you should do about them: A 200 code is a normal response, which means the customer can get the content they requested (such as your full website page, an image on the page, etc). You want as many 200 codes as possible, as it means a good experience for your customers. A 3XX code typically means there was a redirect of some kind. This does not mean anything is broken, however, it may mean longer loading times for your customers as at least two items need to be served instead of one (the original and the redirect). You will want to review your 3XX codes and make sure the redirects you have setup for your website are necessary, and then remove the unnecessary ones. You can also update marketing campaigns to point traffic directly to the end destination instead of continuing to point to a site that will trigger a redirect. A 4XX or 5XX code means that your customer’s request was not answered and can indicate broken links or application error. The difference between a 4XX and a 5XX has to do with why the error took place, and a developer can dig into each error to find out the reason. The most common error in the bucket is a 404 which means that the page was not found. You can setup custom error messages in Section to give your customers a better experience when this does happen until you fix the link. A 7XX code has to do with the connection, and may be the result of problems with the connection your customer is using to make the request and not the result of your website.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/magento-metrics-extension/","objectID":"9287073da391cb77bf4501258a07237f_0","order":0,"tags":null,"title":"Magento Metrics"},{"content":"Grafana - Custom Dashboards It may be helpful for you to create a custom dashboard that is specific to your application. You can create your own dashboard by either starting from scratch or duplicating an existing dashboard. Creating a dashboard from scratch To create a dashboard from scratch: Click on the Grafana logo in the left hand corner. Open the Dashboards dropdown. Click on New. Select the type of panel you want to display (Graph, singlestat, table, pie chart, etc). Click on the Panel Title and then click on th edit button as depicted below: From here, simply designate the desired metrics to display. A completed example is pictured below: This screenshot contains several features of interest: a) Note that the Queries to dropdown must be changed to Graphite. This connects the dashboard to the graphite metrics associated with your account. b) In order to query the data set and see a visualization, you will need to specify a query. Below the Queries to source tab, you will see an empty query with a select metric option. Click here to begin enumerating the query. Section already provides dashboards for a number of common queries by default, but you can use this technique to visualize any relevant metrics that are not already being reported. For help determining what metrics are available, visit our documentation on Graphite c) Grafana dashboards can perform and visualize multiple queries simultaneously. This allows you to compare two separate metric values, such as 4xx and 5xx errors. Finally, save your changes by clicking the Save icon on the top of the screen. Duplicating an existing dashboard To create a dashboard from an existing dashboard: Click on Dashboard settings at the top of the screen Click on Save as\u0026hellip; Rename the new dashboard Click save. In order for these changes to be permanent you MUST remove the system tag from this dashboard. To do this: Click on Dashboard settings once again Click on Make editable. This will allow you to make changes in the dashboard. In the section called Tags, you will want to remove the system tag (image below).","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/monitoring/make-grafana-dashboard/","objectID":"796a2739c213f1cc4e4c9211c87c28db_0","order":0,"tags":null,"title":"Make a Custom Grafana Dashboard"},{"content":"Bare Domains are DNS records without www, also called Zone Apex, Naked Domain and Root Domain. In order to go live on Section, you need to setup a CNAME record pointing to the Section platform. While this is simple to do for any subdomain such as www, creating a CNAME record for a bare domain can cause some problems. This is because a CNAME record trumps all other records and can cause issues with MX records — potentially leading to broken email etc. There are several workarounds to this problem: Switch to running your site on “www”. This means that users will type in www.domain.com to get to your website. You would then setup a HTTP 301 redirect from the bare domain to the www version so that users (and SEO) are automatically redirected to the “www” site. With this configuration fully in place, the bare domain points to the origin, www points to Section, and the origin servers redirects to the www. For a deeper discussion of the impact of serving your website off of the www instead of the bare domain, see this article. Use a DNS provider that supports a special ALIAS/ANAME record type at the bare domain. These records are like CNAME records but do not cause the issues described above. If your DNS hosting provider does not support ALIAS/ANAME records, you can switch to Section hosted DNS. For technical background on CNAME’s and the bare domains see: RFC 1034 section 3.6.2.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/domains-dns/make-bare-domain-cname/","objectID":"512d10294c63f7df0de0f06ed227a22b_0","order":0,"tags":null,"title":"Make bare domain CNAME records"},{"content":"What does it do As an asynchronous event-driven JavaScript runtime, Node.js is designed to build scalable network applications. In Node.js, many connections can be handled concurrently. Upon each connection, the callback is fired, but if there is no work to be done, Node.js will sleep. HTTP is a first-class citizen in Node.js, designed with streaming and low latency in mind. This makes Node.js well-suited for the foundation of a web library or framework. Node.js Request Flow Node.js Contract The following defines the requirements to run the Node.js module in the Section platform: Essential HTTP server listening a port defined by process.env.PORT for HTTP/1.1 — never using HTTPS or any other port. In the event communicating upstream or to another service you must connect to next-hop:80 as HTTP, never HTTPS. The platform will ensure next-hop resolves to the next proxy in the chain or the origin — whichever is next upstream. Specify a X-Forwarded-Proto: https HTTP request header to perform HTTPS requests to the origin. Proxy must handle logs according to these requirements: All log files must be written under the /var/log/nodejs directory. Your config must contain a .gitignore file which ignores the node_modules directory. Your Node.js config must contain a package-lock.jsonfile which is generated by npm. Your Node.js application must contain a npm start script which must start your HTTP server. Note: You must use npm as yarn is unsupported for now. Optional Your application should handle run time errors which does not crash the application. Things you can rely on Module can expect a X-Forwarded-Proto: https request header for HTTPS connections from the browser. Assume HTTP otherwise. Module can expect a True-Client-IP request header containing the IP address of the client connecting to the Section servers. The X-Forwarded-For request header will be also be present but may contain multiple IP addresses from other HTTP proxies between the client and the Node.js module.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/explanations/modules/nodejs/","objectID":"2d2035ce16f500a0bc752c1634b0791f_0","order":0,"tags":null,"title":"Node.js"},{"content":"Context If you wish to configure the Section platform to pass the ACME Challenge route through to your origin please follow the following steps. Please note that enabling this feature will render the Section provided Let\u0026rsquo;s Encrypt SSL certificates unusable. Steps Follow the below steps to deploy this change: Locate the section.config.json file in the root of your Section git repository. Locate environment block (in this example we\u0026rsquo;ll be using Production). ... \u0026#34;environments\u0026#34;: { \u0026#34;Production\u0026#34;: { \u0026#34;origin\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;origin.example.com\u0026#34;, \u0026#34;enable_sni\u0026#34;: true }, ... Add the following key/value to the origin block: \u0026quot;proxy_acme_challenge\u0026quot;: true ... \u0026#34;environments\u0026#34;: { \u0026#34;Production\u0026#34;: { \u0026#34;origin\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;origin.example.com\u0026#34;, \u0026#34;enable_sni\u0026#34;: true, \u0026#34;proxy_acme_challenge\u0026#34;: true }, ... Commit your changes and push to your desired branch.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/passthrough-acme-challenge/","objectID":"fc6e4af989c12ff45b8c63bea87c7b70_0","order":0,"tags":null,"title":"Passthrough ACME Challenge HTTP Request"},{"content":"Section supports a number of payment methods. Credit Card The default payment method is by credit card which can be added to your account in the billing portal. Section stores all credit card details in secure vaults provided by our payment gateway providers. We do not store any credit card information on the Section platform. Add or Update your credit card, visit the Section Billing Portal: first click on the \u0026ldquo;gear\u0026rdquo; icon in your menu then navigate to \u0026ldquo;Account\u0026rdquo;. Here you will find the \u0026ldquo;Visit Billing Portal\u0026rdquo; button which will take you to our hosted billing portal. You have the option to set up a unique password for your billing portal. Within the Billing Portal, you can attach different payment methods to each website. Note: Section does not currently support American Express as a valid credit card payment method. Other Billing Methods Section also supports invoice and 12 and 24 month contracts with discounts available for longer term agreements. Please contact us to discuss alternate billing methods.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/payment-methods/","objectID":"8e55ec1ba5b06eb656c0ff2f65abdffb_0","order":0,"tags":null,"title":"Payment Methods"},{"content":"If you use Varnish Cache for Content composition using Edge Side Includes you may need to configure Varnish Cache to process ESI directives in files that don\u0026rsquo;t look like XML. For example, if you are using ESI in an AJAX call that returns some JSON, you might need to enable disable Varnish\u0026rsquo;s XML check. To do this: Create a file in the varnish directory named proxy-features.json. Add the following content: { \u0026quot;feature/esi_disable_xml_check\u0026quot;: true } ```. 1. Commit the file. 1. Push your changes to the Developer PoP or Aperture. Whilst this change will take effect in the Developer PoP, you may need to contact support for this to take effect in production.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/configure-varnish-cache-to-process-esi-directives-in-json-responses/","objectID":"c8858e96d19237c859d6cc7ec981a73b_0","order":0,"tags":null,"title":"Process ESI Directives in JSON responses"},{"content":"Proxy Requirements The following defines the interaction between the proxy container and the Section proxy hosting platform: Essential Proxy should listen on TCP port 80 for HTTP/1.1 on its public interface — never HTTPS or any other port. It may listen on other ports on its loopback interface for internal use only. Proxy must connect upstream to next-hop:80 as HTTP, never HTTPS. The platform will ensure \u0026ldquo;next-hop\u0026rdquo; resolves to the next proxy in the chain or the origin — whichever is next upstream. The proxy must resolve the next-hop name first via /etc/hosts and then via the nameservers and other options defined by /etc/resolv.conf. All other DNS resolution (e.g. external resolvers) are unsupported and will be blocked by the firewall. Proxy must handle logs according to these requirements: All HTTP access must be written to the container\u0026rsquo;s stdout stream in either JSON format or LTSV format. All diagnostic or error logs must be written to the container' stderr stream. Log files should not be used. They will not be accessible outside the proxy and the proxy is responsible managing file growth. An executable at /opt/section/validate.sh will be executed by Aperture during the git push pre-receive hook to validate that the user\u0026rsquo;s proxy configuration is correct. This executable must exist, even if it takes no action. It does not need to be a shell script, any file with this name and appropriate file mode is acceptable. The user\u0026rsquo;s configuration for the proxy will be available in the /opt/proxy_config/ directory. The process must return a zero exit code and zero output if config is valid. The process must return non-zero exit code if config is invalid and output reason for validation failure to the stderr stream. The script will have zero network connectivity so the process will not be able to issue requests to external services as part of the validation. Optional Proxy should expect that /opt/proxy_config/ directory will contain the configuration for this proxy. This will be the proxy-specific subdirectory from the Section Application git repository. Assume the directory contents are read-only. Things you can rely on Proxy can expect X-Forwarded-Proto request header will equal https for HTTPS connections from the User-Agent. Assume HTTP otherwise. Proxy can expect X-Forwarded-For request header will be present. A True-Client-IP request header will also be present and contain a single IP representing the downstream client\u0026rsquo;s address extracted from the X-Forwarded-For header. Proxy should configure HTTP/1.1 keep-alive to be enabled for both downstream and upstream connections. Additional Considerations The proxy image will be published in a publicly accessible docker repository. This repository allows your image to be downloaded to both production servers and section.io users using the Developer PoP.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/reference/proxy-contract/","objectID":"43bee23695ff3a59b2e6c7cae63c37fd_0","order":0,"tags":null,"title":"Proxy Contract"},{"content":"The following steps will enable you to prime the CDN caches and follow a process that identifies caching issues for resolution ahead of actual customer traffic: 1 Load your site\u0026rsquo;s Homepage 3-4 times This will ensure that assets are stored in cache and any optimizations that are being applied are activated 2 Browse to another page (eg product page) If your site is an ecommerce site add a product to cart (or perform a similar action that personalizes the users experience) Test checklist item: Confirm that add to cart action works 3 Browse back to the Homepage This tests the experience when a user has performed some actions elsewhere and returns to a cached / optimized page Test checklist item: Confirm that user still has products in cart and page rendering looks normal 4 Login to your sites User portal If your site has an area for users to manage their username and password and other account related settings login now Test checklist item: Confirm that login works and user portal rendering looks normal 5 Browse back to the Homepage This tests that your site renders properly after logging in when browsing a cached / optimized page. Test checklist item: Confirm that the page displays the user logged in status correctly 5a (Optional) Load the Homepage in a new Incognito window Loading your website in an Incognito window (in Chrome browser for example) simulates a new user that is not related to your existing user on the site. This enables you to confirm that things like cart/logged in status are unique per user. Test checklist item: Confirm that the page displays correctly and that the page does not have any cart items or logged in status 6 Complete Checkout/Key call to action Complete the primary call to action on your site to ensure that users can complete this step without any issues. Test checklist item: Confirm that an order / booking / inquiry has been placed and that your user has received any confirmation emails as appropriate 7 Login to your sites Admin (CMS) portal and reload 3-4 times Tests that the user portal of your site is functioning when assets may have been cached / optimized Test checklist item: Ensure that you can perform 1-2 of your most common CMS functions Testing Complete - Go live! Now that you have followed the above process, you have tested the core functionality of your site. Through the above process it\u0026rsquo;s critical to focus on the functional elements of testing. Seeing actual user performance will only be relevant when you have actual users on your website.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/testing-effectively/","objectID":"b14a68e039087d67489d0d5146bb6c9e_0","order":0,"tags":null,"title":"Recommended Test Suite"},{"content":"Overview Varnish Cache allows you to create synthetic HTTP redirect responses with the use of vcl_synth. Redirect syntax Below is an example of how to deliver a synthetic redirect 301 response using VCL syntax 4.0. This example will deliver a 301 response with a location header to redirect to \u0026ldquo;/world\u0026rdquo; if a request matches the URI path \u0026ldquo;/hello\u0026rdquo; sub vcl_recv { if (req.url ~ \u0026#34;/hello\u0026#34;) { return (synth(801, \u0026#34;/world\u0026#34;)); } } sub vcl_synth { if (resp.status == 801) { set resp.http.Location = resp.reason; set resp.status = 301; return (deliver); } }","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/redirect-a-request/","objectID":"1765bc89ddd3fb7d8743dafc1d10e486_0","order":0,"tags":null,"title":"Redirect a request"},{"content":"Remove a User from an Account To remove a user from your account (requires admin status): Click on Account and then Manage Users in the top right of the management console. Click Remove From Account next to the relevant user.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/user-management/remove-a-user/","objectID":"45bf62174dae76a94eb4d94570c4917e_0","order":0,"tags":null,"title":"Remove a user from your account"},{"content":"The section.config.json file This file in the root of your git repository found under the Advanced config menu in Aperture, defined which proxies/modules are running for your environment dictated by the git branch. For example, if your application is setup with Varnish Cache 6.1.1 and Kraken 2.0.0, you should see this at the top of your config file: \u0026quot;proxychain\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;varnish\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;varnish:6.1.1\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;kraken\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;kraken:2.0.0\u0026quot; } ] 1) Removing a proxy/module If you\u0026rsquo;d wish to remove a proxy/module from your proxy stack, you can simply remove the object from the proxychain array in your section.config.json file. After removing the Kraken module, our file looks like: \u0026quot;proxychain\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;varnish\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;varnish:6.1.1\u0026quot; } ], 2) Deploy your new configuration Once you\u0026rsquo;ve made the above changes to your configuration files, you can simply commit and push your changes to the desired branch and the Section platform will remove this module from your HTTP delivery chain.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/remove-a-proxy/","objectID":"f8d04cb6ab1c69ade5ebaeaa98aea9ef_0","order":0,"tags":null,"title":"Removing a module from your proxy stack"},{"content":"A Guide to hooking up multiple origin servers to one Section environment and orchestrating incoming HTTP traffic distribution among them. When you have a single origin or upstream server, your section.config.json file will look something like this: \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;override.example.com\u0026quot; } However, there are cases where it is useful to have two different upstream services — perhaps you want to make two backend systems appear on the same domain. Section supports multiple origins in a single configuration which allows you to run multiple backends into one domain. Adding More than One Origin Server Adding another backend service or origin to your configuration involves the following steps: 1) Define Alternate Origins To define multiple origins, we need to add configuration information about the additional origins to our section.config.json file. Working from the case above, we can add a second origin by adding an alernate_origins block. Here\u0026rsquo;s an example of adding origin2.example.com to section.config.json \u0026quot;origin\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin.example.com\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;override.example.com\u0026quot; }, \u0026quot;alternate_origins\u0026quot;: { \u0026quot;origin2_example_com\u0026quot;: { \u0026quot;address\u0026quot;: \u0026quot;origin2.example.com\u0026quot;, \u0026quot;host_header\u0026quot;: \u0026quot;origin2.example.com\u0026quot; } } Note that the alternate origin definition is a named object. We advise naming the alternate origin similarly to the address field. The address field tells Section the IP address or DNS name that it should connect to. You will also want to specify the host_header that will be used on the HTTP requests that Section makes to this upstream. 2) Configure your Section proxy stack to forward requests to the alternate origin Once you have established multiple origins by configuring your section.config.json file, you can choose to route incoming requests to different origins based on criteria of your choosing. When an incoming request hits the LastProxy(The final proxy in your chain), LastProxy looks for request headers and routes the request to the specified origin. Generally speaking, this is done within the Varnish Cache proxy. Here\u0026rsquo;s an example using Varnish Cache VCL that you could incorporate into your default.vcl. sub vcl_recv { if (req.url ~ \u0026quot;sitemap.xml\u0026quot; ) { set req.http.section-origin = \u0026quot;origin2_example_com\u0026quot;; } } This if statement would be included in your existing vcl_recv function, or, as is allowed with vcl files, could be written as a part of a new vcl_recv block for the sake of organization. This example says \u0026ldquo;If the requested URL contains sitemap.xml, then add a new header, section-origin, with the value origin2_example_com\u0026rdquo;. Now, when Section receives a request for sitemap.xml it will add the HTTP request header, which signals the LastProxy to forward the request to the specified alternative origin instead of your primary origin.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/multiple-origins/","objectID":"56fbe84071cc7e04267ee1fb88ed19bb_0","order":0,"tags":null,"title":"Run multiple origins in one environment"},{"content":"This is a guide to help you run some basic tests against your website using webpagetest.org, a free real browser synthetic testing agent. While synthetic tests do not necessarily provide an accurate indication of how fast your site will be in the hands of your users, they can be useful to help you understand which items you can work on to the improve performance of individual pages. By focusing on key pages, you can improve the overall performance of your website. These tests assumes you have signed up with Section and that you have added your application. Check out our set of recommended tests for help ensuring that you\u0026rsquo;ve covered all your bases. Test without Section Visit webpagetest.org and run a test against a sample page from your website. Run 5 tests with first and repeat views from a location which may be relevant to your users. This should give you a good picture of your origin\u0026rsquo;s performance without the benefits of Section. Test with Section 1 Find the cname Record for Your Application Visit your Section portal and view the Change DNS settings. Also found under the Repository settings if you have not selected to use Section hosted DNS offering. You should see something like: www.website.com.c.section.io Copy this as you will need it for the next step. 2 Set Webpagetest to Test the Site Running Through Section At the home screen of webpagetest, select the \u0026ldquo;Script\u0026rdquo; tab and enter a DNS reroute so that webpage test thinks the origin server for your website is at Section. You may also need to set webpagetest so that it ignores any SSL errors assuming you have a cert installed on your website which you have not yet installed on Section. Run another 5 tests with first and repeat views. 3 Review Your Results You should be able to see the Section markers in the responses for the items. Select one of the webpagetest waterfalls and click on the response. The Section id provides you with confirmation that the test has traversed the Section platform. 4 Optimize Your Website Performance Now you can modify your VCL in Section platform and re run multiple tests for caching or modify the page to serve entirely HTTPS so you can take advantage of Section HTTP/2 platform. The cache hit headers will be apparent on the responses you see in webpagetest. You can also then correlate the responses to your logs and metrics in Section portal. Simply take a copy of the Section ID for a particular response anc copy and paste it into the query frame in Kibana in Section portal. This will provide you with detail for that particular request and how it was dealt with at the Section platform. 5 Rinse and Repeat This process can allow you to see the impact you can have on your website with Section. As you progressively improve the configuration in Section you should be able to see these changes reflected in your webpagetest results. Once you have made your DNS change, these tests become even more simple as the script you entered will no longer be required.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/testing-via-internet/","objectID":"b0fd57a5403c494c0247fab581440f54_0","order":0,"tags":null,"title":"Run WebPagetest On Your Website"},{"content":"Although Minikube functions functions best when pointed at an origin server with a publicly available IP address, it is possible to connect DevPop to a local development server. The source of complexity here is dealing with the network bridge between the host machine and the Minikube virtual machine. The following is a set of directions for implementing this using virtual box and a local server running on port 80, but the necessary configuration may vary if you have an alternative setup. Start your local server on port 80. Start Minikube. Once Minikube is running and it\u0026rsquo;s network has been established, you should be able to visit your localhost server on both 127.0.0.1 and 192.168.99.1 (If not, subsequent steps will not work). If successful, this means that the Minikube VM can access your host machine\u0026rsquo;s localhost on 192.168.99.1. In the DevPop UI, add both 192.168.99.1 and the relevant hostname (such as www.example.com) as the origin for the Section configuration you wish to run in front of your origin server. In your hostfile, map the hostname you set in the previous step (www.example.com) to the IP address of Minikube (likely 192.168.99.100 — verify by running minikube ip in your command line). Visit your hostname www.example.com in your browser. If everything is configured correctly, then your browser will send the request to DevPoP on 192.168.99.100, which will then pass it to the local origin server running on 192.168.99.1. Note that this request must be made over HTTP and not HTTPS.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/developer-workflow/dev-pop-with-local-server/","objectID":"d2696f8ce3aab7aab6b2e475038e3a21_0","order":0,"tags":null,"title":"Running Minikube with a Local Origin"},{"content":"In this document and video we show you how to search the HTTP Logs in Section\u0026rsquo;s dashboard by using the value of the `section-io-id' HTTP response header which is present on every response served by Section platform. Obtain the section-io-id header value. If you are using a broswer, you shoulw be able to open up broswer Dev-Tools -\u0026gt; Network, load the page then you should see all the requests the browser made. Find the request that is of interest and click it. Under Headers, look for the section-io-id response header. It should look something like this: section-io-id: 97031a48002326276ebc1aef2eb40f2d Copy just the value, e.g 97031a48002326276ebc1aef2eb40f2d then follow the instructions below to search for logs associated with that response. Searching in Kibana Intro 0:00 Search by section.io ID 0:49 Edge proxy 2:17 Varnish logs 2:58 WAF 3:34 Origin proxy 3:56 Filter by ID 4:14","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/search-logs-using-section-io-id/","objectID":"1c0da703907ed54ce51ba7f557b8c599_0","order":0,"tags":null,"title":"Searching HTTP logs using section-io-id"},{"content":"Configuring Varnish Cache to serve stale content is very useful for when your origin crashes. This behavior is achievable when running Varnish Cache as a reverse proxy within the Section Content Delivery Grid. Prerequisites Make sure you have an account on Section, and have selected Varnish Cache to run in your proxy stack. Note: This guide will be using VCL 4 syntax, so if you are interested in VCL 3 syntax please reach out to us at support@section.io and we can provide you instructions to upgrade your Varnish instance to support VCL 4 Set up This guide assumes you know basic VCL and the flow of HTTP traffic through Varnish Cache. Step 1 - vcl_backend_response We will need to add logic within vcl_backend_response to begin the process for serving stale content. You will need to check for the backend response status, from your origin server, for any \u0026ldquo;5XX\u0026rdquo; errors and return abandon. You will also need to set the grace period of the object. sub vcl_backend_response { if (beresp.status \u0026gt;= 500 \u0026amp;\u0026amp; beresp.status \u0026lt;= 599) { return (abandon); } ... set beresp.grace = 24h; } Step 2 - vcl_synth In vcl_synth we need to check the resp.status for a 503 code as this is the code set by return(abandon). If this is the case, we will utilize restart to run through the VCL code again. sub vcl_synth { if (resp.status == 503) { return (restart); } ... } Step 3 - vcl_hit This part is where we actually tell Varnish Cache to serve stale content. If you are not using your own sub vcl_hit then this is the built in sub vcl_hit routine. A great explanation of the following code is provided in the Varnish docs sub vcl_hit { if (obj.ttl \u0026gt;= 0s) { // A pure unadulterated hit, deliver it return (deliver); } if (obj.ttl + obj.grace \u0026gt; 0s) { // Object is in grace, deliver it // Automatically triggers a background fetch return (deliver); } // fetch \u0026amp; deliver once we get the result return (miss); } Testing You can test this logic, by enabling maintenance mode on your server which will serve some type of 500 error. Keep in mind if the request is not in the cache before your origin goes down, the end user will still receive an error.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/configure-varnish-cache-to-serve-content-while-the-backend-is-offline/","objectID":"fe69ac880fceb48b6e67141fe94a2fc5_0","order":0,"tags":null,"title":"Serve stale content while the backend is offline"},{"content":"When your application is first created it will be served over HTTP and via HTTPS using a default network certificate. Once we detect DNS has been changed on to our platform we will provide a signed and valid certificate through Let\u0026rsquo;s Encrypt. If you have added multiple domains to the application, a Let\u0026rsquo;s Encrypt certificate will be provided for each domain. If you have provided your own custom certificate, you need to upload a certificate for each domain (even if they are listed as alternate names on the same certificate) using our API. You can choose to upload a custom certificate for only some of the domains in the application if you choose, the others will use the Let\u0026rsquo;s Encrypt certificate issues by Section. Each certificate has a short validity period and will be renewed 30 days prior to expiry. If you require wildcards, multi hostname or extended validation (EV) certificates you will need to provide your own certificate. Add custom certificate through aperture To use a custom certificate for your application you will need to obtain a certificate and private key pair. For production use you should use a certificate signed by a trusted root Certificate Authority (CA). In development scenarios, you may find a self-signed certificate is sufficient (Beginners guide) (Certificate Generation) 1) Get your properly-formatted certificate You will need to ensure you have the public certificate in Base64-encoded DER-encoded (PEM) format. It will look something like this: -----BEGIN CERTIFICATE----- MIIF6DCCBNCgAwIBAgIQBBHej1O0YvalqGG3EuxrWTANBgkqhkiG9w0BAQsFADBw MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 ... tOiS1jXb8xWWRRZyxrZbpaybPN3qkrNdqxBlyuPIy2u0UKYuovcup8a9x7ZfoJsB I5JUNzQIPHaH0kP40DdTBNmczS4UiWaoY3pnlw== -----END CERTIFICATE----- We have omitted most of the lines in the example but expect 30 or more in yours. 2) Specify any intermediate certificates If your certificate is signed by a Certificate Authority, then it will typically have been signed by an intermediate certificate or two, not by the CA root certificate. As an example, the certificate chain for www.example.com looks like this: DigiCert (the CA root) \\- DigiCert SHA2 High Assurance Server CA (an intermediate cert) \\- www.example.com (the end-entity cert) If you have any intermediate certificates in your chain you should have them in a separate file. You can and should omit the root certificate. The certificate chain for www.example.com result would look like this: public certificate at the top: -----BEGIN CERTIFICATE----- MIIF6DCCBNCgAwIBAgIQBBHej1O0YvalqGG3EuxrWTANBgkqhkiG9w0BAQsFADBw MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3 ... tOiS1jXb8xWWRRZyxrZbpaybPN3qkrNdqxBlyuPIy2u0UKYuovcup8a9x7ZfoJsB I5JUNzQIPHaH0kP40DdTBNmczS4UiWaoY3pnlw== -----END CERTIFICATE----- followed by any intermediate certificate(s): -----BEGIN CERTIFICATE----- MIIEsTCCA5mgAwIBAgIQBOHnpNxc8vNtwCtCuF0VnzANBgkqhkiG9w0BAQsFADBs ... 0wGjIChBWUMo0oHjqvbsezt3tkBigAVBRQHvFwY+3sAzm2fTYS5yh+Rp/BIAV0Ae cPUeybQ= -----END CERTIFICATE----- Again most lines have been omitted and replace with \u0026hellip; The last input you require is your certificate’s corresponding RSA private key in PEM format. It will look slightly different, something like this: -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQCqGKukO1De7zhZj6+H0qtjTkVxwTCpvKe4eCZ0FPqri0cb2JZf wmJG8wVQZKjeGcjDOL5UlsuusFncCzWBQ7RKNUSesmQRMSGkVb1/3j+skZ6UtW+5 ... U9VQQSQzY1oZMVX8i1m5WUTLPz2yLJIBQVdXqhMCQBGoiuSoSjafUhV7i1cEGpb8 37sJ5QsW+sJyoNde3xH8vdXhzU7eT82D6X/scw9RZz+/6rCJ4p0= -----END RSA PRIVATE KEY----- It is important that the private key is not password protected. Also, unlike the default for some Base64 encoding tools, the line length must be 64 characters. In most scenarios the openssl software can help produce the required files and convert them to the appropriate format. 3) Install the certificate in Section Once you have your certificate and key in the formats described above, you can install them into Section. Log in to Aperture for your application, and in the sidebar under the Set up header select HTTPS. Copy \u0026amp; paste the certificate files you prepared earlier into the input boxes as labeled, then click Save Changes. Make sure the certificates are in the proper order. For help on that, check out [our guide] (/docs/how-to/https/determine-tls-certificate-order) This will deploy your certificate out to our delivery nodes. Once you have saved your public certificates and private key, when you come back to the HTTPS page the private key will not be displayed on screen as it would be a security risk to display it. Upload a certificate using the API 1) To add an additional domain certificate to your application via the API POST /account/{accountId}/application/{applicationId}/environment/{environmentName}/domain/{hostName} Note: Domains can only be added to a root application (ie pathPrefix of /). Domains added to this application\u0026rsquo;s environment will also be used for the corresponding environment in the sub-apps. If there is no body payload, the domain name will have a Let\u0026rsquo;s Encrypt certificate provisioned for it. A custom certificate can be provided in this format: { \u0026quot;public_certificates\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;private_key\u0026quot;: \u0026quot;string\u0026quot; } 2) To remove a domain via the API DELETE /account/{accountId}/application/{applicationId}/environment/{environmentName}/domain/{hostName} To add a custom certificate to an existing domain via the API: POST /account/{accountId}/domain/{hostName}/https with the following body payload: { \u0026quot;public_certificates\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;private_key\u0026quot;: \u0026quot;string\u0026quot; } Server Name Indication Parts of the Section platform are using shared infrastructure. One component important in this context is the TLS Offload Proxy, implicit in all Proxy Stacks. Its role is to accept end-user HTTP and HTTPS connections for multiple web applications on multiple domains, handle any TLS handshake and then route requests to the correct Proxy Stack. For non-HTTPS requests, routing is easily performed by parsing the Host header present in any standard HTTP/1.1 request. For HTTPS it is a little more complicated. Traditionally during an SSL/TLS handshake, the server provides its certificate (containing the domain names) to the client before the client has indicated which domain (or Host) its request is intended for. Thankfully TLS has since introduced the Server Name Indication SNI extension which provides a mechanism for the client to specify the intended Host of its request before the server responds with its certificate. SNI allows the TLS Offload Proxy in Section to select the correct certificate to supply to the client and then continue routing the request to the correct Proxy Stack just as per a plain HTTP request. When a certificate is provided in an application’s section.config.json file it is being used for HTTPS requests from SNI-enabled clients only. Some clients, eg old mobile browsers and most Windows XP browsers, do not support SNI and will not be able provide the necessary information for Section to offer the correct certificate for HTTPS requests. By default these clients will receive a fall-back certificate which is not valid for the Host their request is intended for and these clients will report a security error. If you need","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/setup-https/","objectID":"f8a2e7b453b4a628447a07efc96ee520_0","order":0,"tags":null,"title":"Set up HTTPS and HTTP/2"},{"content":"to support older non-SNI-capable clients, contact Section support to discuss adding your application’s Host name to the fall-back certificate.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/setup-https/","objectID":"f8a2e7b453b4a628447a07efc96ee520_1","order":1,"tags":null,"title":"Set up HTTPS and HTTP/2"},{"content":"Section\u0026rsquo;s Node.js module allows you to deploy your own Node.js code at the Edge. Below are the following steps you will need to take to get your Node.js app up and running within your Section application. Step 1: Add Node.js module to Section application Pull your Section application repository to your local machine. In the root of your repository, add a directory titled nodejs. Then edit section.config.json file in the root directory and insert the following object into the proxychain object located in the json file. This can be inserted at the index you prefer: { \u0026quot;name\u0026quot;: \u0026quot;nodejs\u0026quot;, \u0026quot;image\u0026quot;: \u0026quot;nodejs:10.11.0\u0026quot; } Step 2: Define URL paths to be served by the Node.js module. Create a new file under the nodejs directory named server.conf. This is an Nginx configuration file where you can configure location blocks to route traffic to either the Node.js process or the next module in your proxy stack. To route traffic to your Node.js process you\u0026rsquo;ll need to use the following Nginx configuration in the location block. location /examplePath1/ { proxy_set_header X-Forwarded-For $http_x_forwarded_for; proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto; proxy_set_header Host $host; # This sends the request to the local Node.js server. include /etc/nginx/section.module/node.conf; } For all requests to be routed to the Node.js process, you can replace location /examplePath/ with location / If you would like to bypass the Node.js process for certain URL paths, use the Nginx configuration location block: location ~ \u0026quot;/examplePath2/\u0026quot; { proxy_set_header X-Forwarded-For $http_x_forwarded_for; proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto; proxy_set_header Host $host; # This sends the request to the upstream module or origin web server. proxy_pass http://next-hop; } Step 3: Setting up your Node.js app Your Node.js application will live entirely in the nodejs directory and needs to satisfy the following requirements: Node.js Contract Check out an example Nuxt application that will work out of the box with Section Node.js module. Step 4: Deploy to the Edge Commit all your changes to your Section repository and desired branch/environment to trigger the deployment process. This can take a while depending on a number of factors such as the size of all the Node.js modules required to run the Node.js application.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/nodejs/","objectID":"aa634b41ad267e736738fb52f3dfa80b_0","order":0,"tags":null,"title":"Set up Node.js"},{"content":"A guide to setup custom outage pages Section has an Outage Page feature that will allow multiple HTML pages to be uploaded on to the platform and displayed during maintenance or other planned down times. 1) Design an outage page The Outage Page feature is designed for HTML only. We recommend keeping the HTML simple. Any static assets linked in the HTML should be hosted off domain, such as on AWS S3. 2) Upload an outage page You can place one or more HTML files in the outage_pages folder in your application repository. If this folder does not exist, you can create it. Each HTML file that is uploaded in to the repo will show up under the Outage Page portal page which you will find on the left hand side nav bar. For example, if you uploaded the following 3 files into the outage_pages folder: You should see them displayed in the Outage Page portal as per the screenshot. 3) Enable/disable outage page When you wish to enable outage mode and display one of your uploaded outpage pages, simply check the box next to the page you wish to display and click \u0026ldquo;Engage\u0026rdquo;. You will be prompted to confirm the action. Once confirmed, all requests to the site will be served the outage page. Please be aware that a deployment time of around 30 seconds is expected when you click confirm. When you are ready for users to see the site again, click the Disengage button. 4) Outage page for specific Domains or URLs Right now the Outage Page portal covers all domains and URLs on a Section environment. If you wish to only display an outage page for a select domain or URL path, you will need to do so using Varnish Cache. See this community article for details.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/outage-pages/","objectID":"ee3fb6dca95214fe493c62a1072e19c5_0","order":0,"tags":null,"title":"Set up Outage Pages"},{"content":"Section offers free real user monitoring for any customer that signs up and begins their trial. This enables you to see how your own visitors are experiencing your website performance with the use of a simple JavaScript snippet. Data includes: Back end, front end, and full page load time Throughput Traffic by user agent (browser, device type) Setting up RUM in Section To add RUM to your website, simply login to your Section account and go to \u0026ldquo;Real User Monitoring\u0026rdquo; under \u0026ldquo;Set Up\u0026rdquo; in the left navigation. All you need to do is paste the script tag above your \u0026lt;/head\u0026gt; tag in any HTML document you want to track. Adding with Google Tag Manager To add the Section RUM script within Google Tag Manager, please follow the steps below: Get the RUM script from your Section account and go to \u0026ldquo;Real User Monitoring\u0026rdquo; under \u0026ldquo;Set Up\u0026rdquo; in the left navigation. Login to your Google Tag Manager account and navigate to the container with your domain you wish to add the script to. Click on the red New Tag button. Name the tag “Section RUM”. Under Tag Configuration choose custom HTML. Paste the RUM script into the area that appears. Under Triggering choose All Pages. Click save. In the upper right-hand corner, click Publish and continue to publish all changes. Once you\u0026rsquo;ve completed these steps, you\u0026rsquo;re ready to start collecting performance metrics. Set up RUM with Classifications Section RUM can also provide user statistics subdivided by page classifications, giving you pageload statistics for specific page classifications and site-wide statistics. To setup RUM with page classifications: 1) Decide what classifications you want In order to build out the rest of your RUM script, you need to decide what page classifications you want to collect data for. Our available classifications are: Home,Product, Checkout, Category, and Uncategorised. Note: Make sure you do not change the spelling of \u0026lsquo;Uncategorised\u0026rsquo;. It will not collect the data If you choose to enable them all, these classifications give you statistical metrics on your home page, your individual product pages, your product category pages, and your checkout process. Uncategorised collects metrics on everything that doesn\u0026rsquo;t fall into one of those classifications. 2) Add HTML body classnames for each one of your classifications By the end of this step, all the pages you want tracked need to have a classification-specific class on their HTML body that identifies them to our RUM script. For example, all Product pages need to have some product class, all Category pages need to have a category class, etc. If you are setting up RUM for a Magento application, you probably already have body classes you can use for this. These classnames are included below in the example code for Step #5. If you are using Magento, you\u0026rsquo;ll want to verify that your bodies have these classes and then proceed to the next step. If you\u0026rsquo;re not using Magento but already have classes that appear consistently on the bodies of your pages, feel free to use those and proceed to the next step as well. If you don\u0026rsquo;t have any consistently applied body classes, you\u0026rsquo;ll need to make some. A good classname for your Product classification would be something like rum-product. All that matters is that it makes sense and consistently appears on all pages that you want under that classification. Add these to the appropriate pages. 3) Create a folder in your repository (found under Advanced Configuration) named rum. Note: In order to do this, you will need to pull down your configuration repository onto your local machine. Folders and files cannot be created in the UI. 4) Create a JavaScript file inside rum with the same name as your Hostname/Production domain name. If your Production domain name is www.example.com, then your JS file should be www.example.com.js. Similarly, if you are using a bare domain such as abc.com, then your JS file should be named abc.com.js. 5) Tailor this template to fit your classifications and insert into your JS file: (function (w) { var pageUrl = w.location.pathname; var pageName = \u0026quot;Uncategorised\u0026quot;; if (bodyHasClass(\u0026quot;cms-home\u0026quot;)) { pageName = \u0026quot;Home\u0026quot;; } else if (bodyHasClass(\u0026quot;catalog-category-view\u0026quot;)) { pageName = \u0026quot;Category\u0026quot;; } else if (pageUrl.match(\u0026quot;/checkout\u0026quot;)) { pageName = \u0026quot;Checkout\u0026quot;; } else if (bodyHasClass(\u0026quot;catalog-product-view\u0026quot;)) { pageName = \u0026quot;Product\u0026quot;; } else { pageName = \u0026quot;Uncategorised\u0026quot;; } w.sq_pagetype_override = pageName ; function bodyHasClass(className) { return document.getElementsByTagName(\u0026quot;BODY\u0026quot;)[0].classList.contains(className); } })(window); Double Note: Don\u0026rsquo;t change the spelling of Uncategorised The only sections you should need to configure are the if-statements. The pageName variable will default to Uncategorised, but that default is overwritten if any if-statement resolves to true. The bodyHasClass() method will inspect the body for a given class and return a boolean, but you\u0026rsquo;re free to make the if-logic pass in any other way that makes sense. In the example above, Checkout pages are identified by URL matching as opposed to HTML classnames. What matters is that pageName is set to the right value. 6) Contact Section In order to go-live with your new RUM, you\u0026rsquo;ll need a Section engineer. Email us at support@section.io. Viewing your metrics To view your real user monitoring metrics login to your Section account and go to \u0026ldquo;Monitoring\u0026rdquo; under \u0026ldquo;Real time\u0026rdquo; in the left navigation. From there you can click on \u0026ldquo;Real User Monitoring\u0026rdquo; in the left hand corner of the screen to view your Data Real User Monitoring in Grafana","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/performance/rum/","objectID":"b49ac97b064085faffe4ed742e22dea1_0","order":0,"tags":null,"title":"Set up Real User Monitoring"},{"content":"Overview Varnish Cache gives you the ability to modify, add, and remove HTTP headers on the request and response object. Request Headers The vcl_recv sub routine is called at the beginning of a request and this is where we will be modifying the request headers. We will be adding the header hello with value of world, and removing the user-agent header. sub vcl_recv { ... set req.http.hello = \u0026#34;world\u0026#34;; unset req.http.user-agent; ... } The req.http object is how to access any request header and is only readable from vcl_recv and vcl_deliver. Response Headers The vcl_backend_response sub routine is called once Varnish Cache has received the response headers from the upstream service. We will be modifying the header cache-control and setting the value to public, max-age=600, and removing the server header. sub vcl_backend_response { ... set beresp.http.cache-control = \u0026#34;public, max-age=600\u0026#34;; unset beresp.http.server; ... } The beresp.http object is how to access any response header and is only readable from vcl_backend_response and vcl_deliver.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/set-and-unset-headers/","objectID":"37f7ee84ef0c0d569172cec54724ecce_0","order":0,"tags":null,"title":"Setting and unsetting HTTP headers"},{"content":"In order to provide Section services, Section engages certain sub-processors. A sub-processor may be a Section affiliate engaged in the processing of personal data or a third-party service provider engaged by Section to process personal data on behalf of the customers or users of Section services. For more information on Section data processing obligations, please see our Data Processing Addendum. Sub Processors Name Type Location Amazon Web Services Inc. Third-party sub-processor United States Other Providers In addition, Section uses certain providers which do not have access to personal data but are commonly used systems of distributed services that run Section software content based on the geographic location of the individual accessing the content and the origin of the content provider. Website content served to website visitors and domain name information may be stored with a service provider to expedite transmission, and information transmitted across a service provider may be accessed by that service provider to enable its functions. Name Type Location Google Inc. Other Provider United States Microsoft Inc. Other Provider United States Amazon Web Services Inc. Other Provider United States Digital Ocean Inc. Other Provider United States Network Synergy Corporation Other Provider Australia Subscribers may subscribe to receive notifications of sub-processor changes by subscribing to https://github.com/section-io/docs.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/additional-information/sub-processors/","objectID":"3e16be93e0fddf007e071f1263da7281_0","order":0,"tags":null,"title":"Sub Processors"},{"content":"Instead of using WebPageTest, you may wish to test the site through Section locally using your own browser. You can achieve this by changing how DNS to the site is resolved on your local test machine. Check out our set of recommended tests for help ensuring that you\u0026rsquo;ve covered all your bases. 1 Obtaining a test IP For our managed customers, our engineers will provide you with a test IP and you can skip to part 2. For self serve customers, to find out the IP address of the Section platform for your site, run the following command from a command prompt nslookup site_domain.c.section.io For www.example.com that would be, nslookup www.example.com.c.section.io This will give you one or more IP addresses. e.g. 203.0.113.1 2 Find local DNS lookup file Open the test machine\u0026rsquo;s \u0026lsquo;hosts\u0026rsquo; file in a text editor. This will need to be done as an administrator or with root privilege. Default locations: Windows: C:\\Windows\\System32\\Drivers\\etc\\hosts MacOS and Linux: /etc/hosts 3 Change local DNS lookup file Add a DNS entry into the file that will tell your test machine to send requests for that domain to the Section platform instead of performing a DNS lookup. For the example from point 1) and 2) this would look like: 203.0.113.1 www.example.com Then save the file. 4 Test on browser Now open a new browser tab or window and navigate to the site with dev tools open. Requests served from the section will always have a section-io-id response header. Please note that if you have not uploaded an SSL certificate for the site on to our platform and try to navigate to a HTTPS page, your browser will display a warning about an insecure site, this is expected and not a problem for testing. You can by-pass this warning in Chrome by clicking Advanced then Proceed to site. The warning will disappear once you have either uploaded a custom SSL certificate or after you have pointed DNS at our platform and have provisioned our free SSL certificate. If this header isn\u0026rsquo;t present, check that the HOST file is correctly edited and saved. You may also need to flush the DNS cache of the browser. For Chrome enter the following in the address bar: chrome://net-internals/#dns then clear the host cache. If you still do not see a section-io-id, contact our support team through which ever channel is available to your support plan. We recommend focusing on functional testing of the site, such as user login, add to cart, checkout etc. Performance testing when the site is not live on our platform can yield varying results due to the cache being cold from lack of real world traffic. Remember that the busier a site is, the better it should perform as the cache will be better populated.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/testing-locally/","objectID":"15f546c00ebbeb4ae1450e6e68fbaa67_0","order":0,"tags":null,"title":"Test Website Performance Locally"},{"content":"The Developer PoP is a still in beta and will occasionally have hiccups. This section details some common issues and how to deal with them. Network connectivity and computer sleep Often if you put your computer to sleep with Minikube running, it will break Minikube\u0026rsquo;s network adaptor, and you will get 503 errors without a clear cause when you resume operation. This will also prevent you from downloading proxy images as a part of a git push. In order to re-establish connectivity, you need to disconnect the network adapter and reconnect it. If using VirtualBox, do this by opening the VirtualBox UI, going to your VM\u0026rsquo;s settings, clicking network and then changing the attached to: value from NAT to not attached, and then back to NAT. Toggling this will reset the adapter. Problems with pods in a namespace Sometimes Minikube can fail at the namespace level — either by not properly provisioning all the containers it should, or failing to update existing containers after a new git push, or something else. If this happens, you can delete the namespace from the DevPop UI and push the repository back into Minikube by running git push developer-pop once the deleted namespace has disappeared from the DevPop UI. You can also accomplish this by renaming the git remote and initiating a git push developer-pop. This will create a new namespace and re-trigger all of the container provisioning. Minikube becomes unresponsive, or has other problems Sometimes, Minikube becomes unstable and stops responding to requests altogether. In this case, you\u0026rsquo;ll want to begin this whole process over again with a minikube delete and a minikube start. Note that sometimes (especially if you start Minikube again very quickly after the initial delete), Minikube will spin up on another IP address (say 192.168.99.101 instead of 192.168.99.100). This is fine, but you\u0026rsquo;ll need to adjust your hostfile and your git remote if this occurs. Alternatively, if you restart your computer and then start Minikube again, it will return to the 193.168.99.100 address. Most Minikube problems not caused by some sort of configuration error can be fixed with a fresh boot of Minikube, so give this a shot if the source of the problem is unclear.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/developer-workflow/troubleshoot-developerpop/","objectID":"f972647e250dcf50b25bfaafaf0e2f09_0","order":0,"tags":null,"title":"Troubleshoot Developer PoP Issues"},{"content":"It is possible your Developer PoP IP address may change. If you see a failure on git push with your Developer PoP, try these steps: Ensure Minikube is running: minikube status. Obtain the current IP address of Minikube: minikube ip. Substitute the IP address into the following command to update the git remote in your Developer PoP git remote set-url developer-pop http://192.168.99.100:30090/application-name.git.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/developer-workflow/update-git-for-a-different-developer-pop-ip-address/","objectID":"d8787bac839e2ac5c80d1b67416c5eb6_0","order":0,"tags":null,"title":"Update Git for a different developer pop ip address"},{"content":"1) Navigate to HTTPS Log into your Aperture dashboard and under Set up navigate to the HTTPS page. 2) Select your desired domain The dropdown will automatically fill with the first domain listed in your application. If that\u0026rsquo;s not the one you want, select the correct one from the dropdown. If you have multiple sub domains in this application and wish to upload a wild card certificate or a certificate with multiple domains in the Subject Alternate Name(SAN), you will need to upload the certificate for each domain. You will see a button entitled \u0026ldquo;Specify a custom certificate\u0026rdquo;, or \u0026ldquo;Change custom certificate\u0026rdquo; depending on whether you have previously uploaded a custom certificate for the application. This will render two input boxes on the page — one for \u0026ldquo;Public certificate \u0026amp; chain\u0026rdquo; and the other for \u0026ldquo;Private key.\u0026rdquo; 3) Paste certificate and key You will need to copy the site certificate and any intermediate certificates into the \u0026ldquo;Public certificate \u0026amp; chain\u0026rdquo; box. (For a more in-depth guide on determining certificate order than what follows below, click here). The order of certificates needs to be domain certificate first, followed by any intermediate certificate(s) in order. Make sure NOT to include the root certificate. The certificates should be PEM encoded and will look like this in a text editor: -----BEGIN CERTIFICATE----- /* contents of domain certificate */ -----END CERTIFICATE----- -----BEGIN CERTIFICATE----- /* contents of intermediate certificate */ -----END CERTIFICATE----- If there are more than one intermediate certificate, you will need to make sure they are copied in correct order. -----BEGIN CERTIFICATE----- /* contents of domain certificate */ -----END CERTIFICATE----- -----BEGIN CERTIFICATE----- /* contents of intermediate certificate 1*/ -----END CERTIFICATE----- -----BEGIN CERTIFICATE----- /* contents of intermediate certificate 2*/ -----END CERTIFICATE----- Now copy and paste your private key in to the \u0026ldquo;Private key\u0026rdquo; input area. the private key should look like: -----BEGIN RSA PRIVATE KEY----- /* contents of private key */ -----END RSA PRIVATE KEY----- 4) Upload Once you have copy and pasted the certificates and private key, click the \u0026ldquo;Save Changes\u0026rdquo; button. The portal will perform a check to make sure the certificate is for the correct domain, and the private key is a match for the certificate. Once that is accepted, a deployment is made to the Section platform and you should see the new certificate on the site in moments. You will also see the uploaded certificate information at the right hand side of the HTTPS page. You can also check your newly uploaded certificate using either a command line or 3rd party online tool. See this page for more details","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/https-tls/upload-a-custom-certificate/","objectID":"f8762cd09f79348257fab59b3f22b8e3_0","order":0,"tags":null,"title":"Upload a Custom SSL Certificate"},{"content":"To simplify management for your websites, Section can provide DNS hosting. This is especially useful for pointing a zone-apex record (ie bare domain) at a Section endpoint if your current DNS hosting provider does not support the ALIAS or ANAME record types. Hosting your DNS with Section also provides convenient access to DNS management within the Aperture portal. Begin hosting DNS with Section To enable Hosted DNS with Section: Navigate to the DNS page for your Section application\u0026rsquo;s hosted environment (eg Production). Below the \u0026ldquo;Change your DNS to go live\u0026rdquo; heading you should find another heading labeled \u0026ldquo;Section Hosted DNS\u0026rdquo;. The paragraph that follows will describe the DNS zone name that we have detected that your domain belongs to. If we have detected this zone correctly, and you have access to your DNS registrar to change the name servers for this zone, you can proceed. Please note: Although DNS hosting and DNS registration are often thought of as the same thing and many companies offer both services, they are distinct and can be provided by different companies. The majority of the DNS record changes described in our DNS documentation (making CNAME or ALIAS changes for example) happen in your DNS hosting console, but changing your name servers must be done with your DNS Registrar. Your DNS registrar is the organization from which you purchased your actual domain name, not necessarily where your records are maintained and hosted — although again these often go together in practice. Your DNS registrar is the authority on what DNS servers are allowed to answer DNS queries for your website. Inputting Section nameservers into your DNS registrar gives us permission to respond to DNS queries for your site. Note as well that it is possible to enable the Section DNS zone and check to make sure all the records are correct before you change nameservers. We can provision a DNS zone before this change is made but not answer queries. Click the Enable Hosted DNS button. The DNS page will refresh after a few moments with new instructions. For your convenience, our system will at this point attempt to copy the most common DNS records from your existing DNS hosting provider into our database, but it can miss some records. Follow the link in \u0026ldquo;Step 1\u0026rdquo; of the new DNS page to view the records that have been copied. Verify that the existing records are correct and add any missing records. When you have verified and corrected the copied records, return the the DNS page for your Section application\u0026rsquo;s environment. \u0026ldquo;Step 2\u0026rdquo; on this page lists the new name servers that you will need to enter for your zone at your DNS registrar. Once this is done the change may take up to 48 hours to propagate to all DNS servers globally — after that you can manage your DNS records via Section and your old DNS hosting provider is not used. You will want to wait the full 48 hours and check DNS propagation globally before you turn off your old DNS hosting. Click the Verify button on the DNS page to test if HTTP requests for your site are reaching the Section endpoints. Once you have changed your DNS, please ensure you\u0026rsquo;ve setup HTTPS. Manage your DNS hosted with Section Once Hosted DNS has been enabled for a Section application you can access the zone management page in two ways: From the DNS page of a hosted environment (Step 1 links to the zone page) or \u0026hellip; On the left hand navigation bar under Account click DNS Hosting. From the zone page for a particular zone you can view: The name servers that should be configured at your DNS registrar. The table of DNS records defined in the zone. From the records table you can: Delete records that are not associated with a Section site. Upon first click of the Delete button beside the target record, the button label will change to Confirm, upon clicking again the record will be deleted and begin propagating immediately. Add new records by clicking the Add button at the bottom of the table, filling the required fields, then clicking the Save button. You cannot create a CNAME record at the zone apex, use an ALIAS record instead for this purpose. Edit existing records by clicking the corresponding Edit button. The record types A, ALIAS, or CNAME can be changed to another record type in this same set and when saved the change will be applied so the record does not appear missing during the transition.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/domains-dns/set-up-dns-on-section/","objectID":"f240321a4d09f0480f759dd64c58c3d0_0","order":0,"tags":null,"title":"Use Section hosted DNS"},{"content":"To use Section with outside DNS, simply go to your DNS hosting provider\u0026rsquo;s console and perform the steps necessary to add a new domain to Section. If you have not yet gone through the going live tutorial please visit it for a more in depth view of the entire process DNS Resources Each registrar has its own method of adding CNAME records. Below are some links to instructions on adding DNS records for common hosts and DNS providers. Gandi DigitalOcean Network Solutions GoDaddy Hover Dreamhost Amazon Route 53 Namecheap DNS Made Easy Bluehost DNSimple Hostgator Register.com Having trouble? Contact your domain name provider directly for further assistance.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/domains-dns/set-up-dns-on-other-provider/","objectID":"c0701fe48fedc2c89e46640d0191e0ab_0","order":0,"tags":null,"title":"Use Section with outside DNS"},{"content":"Varnish Cache Configuration Advanced configuration is done via the Varnish Cache Control Language file default.vcl. You can access this file by going to Repository under the Configuration menu in the left nav of Aperture and then clicking on the Varnish Cache file. To help you get started, we\u0026rsquo;ve written some VCL snippets that cover some basic aspects of functionality for you to review. Cache Static Content Normalise Accept-Encoding Enforce HTTPS Block Access Cache Everything Wordpress Caching For more information on how to write VCL, visit Varnish documentation, where each version has its own user guide. Here is documentation for version 4.0","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/sample-varnish-snippets/","objectID":"379b65dd99f365570ef0ebc2c71175ad_0","order":0,"tags":null,"title":"Use Varnish Cache snippets"},{"content":"To make it easy to get started configuring your reverse proxies, Section offers a few basic confguration options for Varnish and Modsecurity. Check out our guide on Advanced Configuration for more advanced configuration topics. Varnish To make getting your CDN setup easier we have a number of configuration options you can enable without having to know how to use Varnish\u0026rsquo;s VCL programming language. To use these go to the Proxy page under the Configuration menu in Aperture. To use these features the following line needs to be in your default.vcl file under the backend declaration (it will be there by default). Note, these basic options work for VCL 4.0 only. include \u0026quot;section-features.vcl\u0026quot;; There are the following configuration options General Settings These apply to all requests no matter what (if any) file extension they have Sort Querystring: Often the order of querystring parameters change especially things like ad tracking parameters. This option sorts every url\u0026rsquo;s querystring parameters into alphabetical order so that they are always the same, improving your cache hit ratio. Static Caching These options apply only to static files, that is, files with the following file extensions: css, js, jp(e)g, png, gif, ico \u0026amp; swf. Cache Statics TTL: Setting this to something other than Retain origin setting will cause us to cache all static resources for the length of time specified. By selecting Retain origin setting we will only cache files that have the appropriate cache-control response header sent from the origin. Remove Querystring: If someone requests a static file from your site with a querystring this will result in a cache miss if no one has requested that exact URL before. By switching this option on we will remove all querystring parameters before caching the object. Don\u0026rsquo;t enable this if querystrings are needed to load static content correctly. Browser Cache TTL: Specifies how long your visitors' browsers will cache files using the cache-control response header sent to their browsers. By selecting Retain origin setting we will not change the cache-control header and will simply pass through what your origin server sends. Changes made to these options will be reflected in the proxy-features.json file in the proxy folder in your application git repository so you can see when options were changed. You can view the VCL that is generated by these options on the Generated VCL tab. To start writing your own VCL, you\u0026rsquo;ll need to head over to the repo. Modsecurity To make getting your CDN setup easier we have a number of configuration options you can enable without writing any code. We\u0026rsquo;ve defined rules that you can view by going to the Proxy page under the Configuration menu in Aperture. If you have both Varnish Cache and Modsecurity setup, you will need to click Proxy in the top nav to display a drop down menu to view both of your reverse proxies and select Modsecurity. The initial configuration in a repository starts ModSecurity’s SecRuleEngine in DetectionOnly mode (this writes log entries but never executes any disruptive actions). This is a great starting point, as you can immediately see possible threats without stopping legitimate traffic to your site. For each config file that we\u0026rsquo;ve setup you can see a list of rules within that file and an on/off toggle. Turning the toggle \u0026ldquo;On\u0026rdquo; will allow the rules to start actively detecting traffic for that rule. In order to turn the rules into a blocking mode, you\u0026rsquo;ll need to do advanced configuration by editing files in the repo. To learn more about what each rule does, visit OWASP Modsecurity Rule Set Project.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/basic-configuration/","objectID":"959924bc273d04865d80b2261f1c94dd_0","order":0,"tags":null,"title":"Using the Quick Configuration"},{"content":"Learning VCL can be a tricky thing so we have made a GUI that let\u0026rsquo;s you cache your static assets and HTML documents without knowing VCL. In the left hand side of your Aperture dashboard there is a section called Quick Config which contains the toggles and inputs to configure Varnish Cache. Varnish Cache Quick Config Configure static asset caching Static asset caching is enabled by default to cache your statics for 6 hours and retain your origin cache control headers for the browser cache. Below is a list of file extensions that we cache by default: css js jpeg png gif ico swf woff There are 3 settings for static caching as well the first is the TTL (Time to Live) which tells Varnish Cache how long to cache your static assets for, the second is a toggle to remove the query strings for all static assets to increase your cache hit rate, and the third is a setting to set the cache-control header for browser caching. Note: be careful with the browser cache setting as it becomes difficult to invalidate the browser cache if you don\u0026rsquo;t have some type of version control for your static assets. Configure HTML caching The first thing you\u0026rsquo;ll notice is a toggle to enable and disable HTML caching for quick and easy incident management in the case of an emergency. When HTML caching is enabled it will by default cache all of your HTML documents that are fetched with a GET request. This is great for sites that are completely static and do not have any customized or authenticated sections or content, for example a shopping cart or customized nav bar per authenticated user. In order to configure your site for a pattern we like to call ISE (Intelligent Session Establishment) you\u0026rsquo;ll need to have a basic understand of Regexes and how your application establishes a session with a Cookie. The first option you\u0026rsquo;ll need to configure are the routes you never want to be cached like admin routes or cart routes. You\u0026rsquo;ll need to construct a Regex that matches on all of your non-cacheable routes. Here is an example: (/admin|/cart|/user) So this pattern will match the following routes and not cache them (these are all examples of routes that will not be cached): /admin /admin/test.html /test/admin/abc/123.html /cart /cart/checkout /user/1 The second option you\u0026rsquo;ll need to configure is the Cookie(s) that identify a users session. This is usually established when a user adds something to their cart, logs in tho their account, etc. These cookies are generally set on a POST request which forces the user out of the caching behavior. This is also configured with a Regex in case you have multiple cookies that establish a user\u0026rsquo;s sessions. (frontend|logged_in_user) Note: Only HTTP GET requests will be cached with this pattern.","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/configure-varnish-with-gui/","objectID":"3cd21aa2c952d457a7575e1f1737bd71_0","order":0,"tags":null,"title":"Varnish Cache Quick Config"},{"content":"Overview This is a guide to help you test the response times in milliseconds across different regions. You will be utilizing the Kibana/HTTP Logs view to break down the time_taken_ms field on the edge-access-log type by the geoip.country_code2 field. Step 1 - Creating the visualization Visit your Section portal and view the HTTP Logs section of your application. This will open up the Kibana view in it\u0026rsquo;s default state. Proceed to click the visualize tab in the upper nav bar which will prompt you to Create a visualization. Select the Line Chart option followed by From a new search. The Kibana view can be opened up in a new tab by clicking the \u0026ldquo;Open in a new window\u0026rdquo; button. This is useful if you wish to share the visualization with a colleague. Step 2 - The search term You should be viewing a line chart with a single data point and the term \u0026ldquo;*\u0026rdquo; in the search input. For this visualization we will want to only view the edge-access-log. Copy and paste the following into the search box to view only the edge logs: _type:edge-access-log Step 3 - Defining the X-Axis You will now configure the X-Axis to display the data over a period of time. On the left hand side of the screen you will want to select X-Axis under the Select buckets type drop down. Select Date Histogram as the Aggregation. Hit the green play button to view the results. At this time you are viewing the total number of edge-access-logs (Count metric) over a period of time. Step 4 - Defining the Y-Axis You will now configure the Y-Axis to display the average time taken in milliseconds for the edge logs. On the left hand side of the screen you will want to select Y-Axis under the metrics section. The Y-Axis is already configured to show the Count metric as we previously saw while defining the X-Axis. Configure the Aggregation to show the Average value instead of Count and this will prompt you to select a field. Here we will find the time_taken_ms option to select. Hit the green play button again to view the results of the average time_taken_ms for ALL edge logs. Step 5 - Splitting the lines You are now viewing the average time_taken_ms value over your selected time frame for all edge logs. Next steps will be to split the lines by country code. On the left hand nav under the X-Axis configuration click the Add sub-buckets option. Select the Split Lines option which will add a second layer to the X-Axis. In the Sub Aggregation option box select the terms option. This will prompt you to select another field, this time you will select the geoip.country_code2 field. Above the Sub Aggregation select box, there is an arrow which allows you to make this aggregation the main aggregate. Select the up arrow. Hit the green play button again to view the results of the average time_taken_ms for edge logs broken down by the top 5 country codes during your selected time frame. Additional notes You can include more than the default 5 results by increasing the Size option under the geoip.country_code2 aggregate configuration. If you are interested in a select few country codes, then you can append search terms to your global search. For example: _type:edge-access-log AND (geoip.country_code2:US OR geoip.country_code2:AU)","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/debugging/view-response-metrics-by-region/","objectID":"216dca4f322fd9397b459542ab122347_0","order":0,"tags":null,"title":"View response metrics by region"},{"content":"Out of the box, Section brings up Varnish Cache metrics. The following is a description of these metrics. Varnish Cache Glossary Key Varnish Cache concepts are described in the Varnish Cache Glossary. Varnish Cache Counters Further detail with respect to key Varnish Cache Counters (Source; [Mankier]) Counter Levels Info- Informational counters Counters giving runtime information Diag- Diagnostic counters Counters giving diagnostic information Debug- Debug counters Counters giving Varnish Cache internals debug information Main Counters sess_conn Sessions accepted (INFO). Count of sessions successfully accepted sess_drop Sessions dropped (INFO).Count of sessions silently dropped due to lack of worker thread. sess_fail Session accept failures (INFO). Count of failures to accept TCP connection. Either the client changed its mind, or the kernel ran out of some resource like file descriptors. sess_pipe_overflow Session pipe overflow (INFO). Count of sessions dropped due to the session pipe overflowing. client_req_400 Client requests received, subject to 400 errors (INFO). 400 means we couldn’’t make sense of the request, it was malformed in some drastic way. client_req_411 Client requests received, subject to 411 errors (INFO). 411 means the client did not send a Content-Length for the req.body. client_req_413 Client requests received, subject to 413 errors (INFO). 413 means that HTTP headers exceeded length or count limits. client_req_417 Client requests received, subject to 417 errors (INFO) 417 means that something went wrong with an Expect: header. client_req Good client requests received (INFO) The count of parseable client requests seen. cache_hit Cache hits (INFO) Count of cache hits. A cache hit indicates that an object has been delivered to a client without fetching it from a backend server. cache_hitpass Cache hits for pass (INFO) Count of hits for pass A cache hit for pass indicates that Varnish Cache is going to pass the request to the backend and this decision has been cached in it self. This counts how many times the cached decision is being used. cache_miss Cache misses (INFO) Count of misses A cache miss indicates the object was fetched from the backend before delivering it to the backend. backend_conn Backend conn. success (INFO) How many backend connections have successfully been established. backend_unhealthy Backend conn. not attempted (INFO) backend_busy Backend conn. too many (INFO) backend_fail Backend conn. failures (INFO) backend_reuse Backend conn. reuses (INFO) Count of backend connection reuses This counter is increased whenever we reuse a recycled connection. backend_toolate Backend conn. was closed (INFO) backend_recycle Backend conn. recycles (INFO) Count of backend connection recycles This counter is increased whenever we have a keep-alive connection that is put back into the pool of connections. It has not yet been used, but it might be, unless the backend closes it. backend_retry Backend conn. retry (INFO) fetch_head Fetch no body (HEAD) (INFO) beresp with no body because the request is HEAD. fetch_length Fetch with Length (INFO) beresp with Content-Length. fetch_chunked Fetch chunked (INFO) beresp with Chunked. fetch_eof Fetch EOF (INFO) beresp with EOF from lack of other info. fetch_bad Fetch bad T-E (INFO) beresp failed due to unknown Transfer-Encoding. fetch_close Fetch wanted close (INFO) beresp with EOF due to Connection: Close. fetch_oldhttp Fetch pre HTTP/1.1 closed (INFO) beresp with EOF due to HTTP \u0026lt; 1.1 fetch_zero Fetch zero len body (INFO) beresp with EOF due to keep-live but neither Chunked or Len. fetch_1xx Fetch no body (1xx) (INFO) beresp with no body because of 1XX response. fetch_204 Fetch no body (204) (INFO) beresp with no body because of 204 response. fetch_304 Fetch no body (304) (INFO) beresp with no body because of 304 response. fetch_failed Fetch failed (all causes) (INFO) beresp fetch failed. fetch_no_thread Fetch failed (no thread) (INFO) beresp fetch failed, no thread available. pools Number of thread pools (INFO) Number of thread pools. See also parameter thread_pools. NB: Presently pools cannot be removed once created. threads Total number of threads (INFO) Number of threads in all pools. See also parameters thread_pools, thread_pool_min and thread_pool_max. threads_limited Threads hit max (INFO) Number of times more threads were needed, but limit was reached in a thread pool. See also parameter thread_pool_max. threads_created Threads created (INFO) Total number of threads created in all pools. threads_destroyed Threads destroyed (INFO) Total number of threads destroyed in all pools. threads_failed Thread creation failed (INFO) Number of times creating a thread failed. See VSL::Debug for diagnostics. See also parameter thread_fail_delay. thread_queue_len Length of session queue (INFO) Length of session queue waiting for threads. NB: Only updates once per second. See also parameter queue_max. busy_sleep Number of requests sent to sleep on busy objhdr (INFO) Number of requests sent to sleep without a worker thread because they found a busy object. busy_wakeup Number of requests woken after sleep on busy objhdr (INFO) Number of requests taken of the busy object sleep list and and rescheduled. sess_queued Sessions queued for thread (INFO) Number of times session was queued waiting for a thread. See also parameter queue_max. sess_dropped sessions dropped for thread (INFO) Number of times session was dropped because the queue were too long already. See also parameter queue_max. n_object object structs made (INFO) Number of object structs made n_vampireobject unresurrected objects (DIAG) Number of unresurrected objects n_objectcore objectcore structs made (INFO) Number of objectcore structs made n_objecthead objecthead structs made (INFO) Number of objecthead structs made n_waitinglist waitinglist structs made (DEBUG) Number of waitinglist structs made n_backend Number of backends (INFO) Number of backends known to us. n_expired Number of expired objects (INFO) Number of objects that expired from cache because of old age. n_lru_nuked Number of LRU nuked objects (INFO) How many objects have been forcefully evicted from storage to make room for a new object. n_lru_moved Number of LRU moved objects (DIAG) Number of move operations done on the LRU list. losthdr HTTP header overflows (INFO) s_sess Total sessions seen (INFO) s_req Total requests seen (INFO) s_pipe Total pipe sessions seen (INFO) s_pass Total pass-ed requests seen (INFO) s_fetch Total backend fetches initiated (INFO) s_synth Total synthethic responses made (INFO) s_req_hdrbytes Request header bytes (INFO) Total request header bytes received s_req_bodybytes Request body bytes (INFO) Total request","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/varnish-metrics/","objectID":"3a77e6967f96b878721150208b007261_0","order":0,"tags":null,"title":"View Varnish Cache Metrics"},{"content":"body bytes received s_resp_hdrbytes Response header bytes (INFO) Total response header bytes transmitted s_resp_bodybytes Response body bytes (INFO) Total response body bytes transmitted s_pipe_hdrbytes Pipe request header bytes (INFO) Total request bytes received for piped sessions s_pipe_in Piped bytes from client (INFO) Total number of bytes forwarded from clients in pipe sessions s_pipe_out Piped bytes to client (INFO) Total number of bytes forwarded to clients in pipe sessions sess_closed Session Closed (INFO) sess_pipeline Session Pipeline (INFO) sess_readahead Session Read Ahead (INFO) sess_herd Session herd (DIAG) shm_records SHM records (DIAG) shm_writes SHM writes (DIAG) shm_flushes SHM flushes due to overflow (DIAG) shm_cont SHM MTX contention (DIAG) shm_cycles SHM cycles through buffer (DIAG) sms_nreq SMS allocator requests (DIAG) sms_nobj SMS outstanding allocations (DIAG) sms_nbytes SMS outstanding bytes (DIAG) sms_balloc SMS bytes allocated (DIAG) sms_bfree SMS bytes freed (DIAG) backend_req Backend requests made (INFO) n_vcl Number of loaded VCLs in total (INFO) n_vcl_avail Number of VCLs available (DIAG) n_vcl_discard Number of discarded VCLs (DIAG) bans Count of bans (INFO) Number of all bans in system, including bans superseded by newer bans and bans already checked by the ban-lurker. bans_completed Number of bans marked ‘’completed’’ (DIAG) Number of bans which are no longer active, either because they got checked by the ban-lurker or superseded by newer identical bans. bans_obj Number of bans using obj.* (DIAG) Number of bans which use obj.* variables. These bans can possibly be washed by the ban-lurker. bans_req Number of bans using req.* (DIAG) Number of bans which use req.* variables. These bans can not be washed by the ban-lurker. bans_added Bans added (DIAG) Counter of bans added to ban list. bans_deleted Bans deleted (DIAG) Counter of bans deleted from ban list. bans_tested Bans tested against objects (lookup) (DIAG) Count of how many bans and objects have been tested against each other during hash lookup. bans_obj_killed Objects killed by bans (lookup) (DIAG) Number of objects killed by bans during object lookup. bans_lurker_tested Bans tested against objects (lurker) (DIAG) Count of how many bans and objects have been tested against each other by the ban-lurker. bans_tests_tested Ban tests tested against objects (lookup) (DIAG) Count of how many tests and objects have been tested against each other during lookup. ‘’ban req.url == foo \u0026amp;\u0026amp; req.http.host == bar’‘counts as one in’‘bans_tested’‘and as two in’‘bans_tests_tested’’ bans_lurker_tests_tested Ban tests tested against objects (lurker) (DIAG) Count of how many tests and objects have been tested against each other by the ban-lurker. ‘’ban req.url == foo \u0026amp;\u0026amp; req.http.host == bar’‘counts as one in’‘bans_tested’‘and as two in’‘bans_tests_tested’’ bans_lurker_obj_killed Objects killed by bans (lurker) (DIAG) Number of objects killed by ban-lurker. bans_dups Bans superseded by other bans (DIAG) Count of bans replaced by later identical bans. bans_lurker_contention Lurker gave way for lookup (DIAG) Number of times the ban-lurker had to wait for lookups. bans_persisted_bytes Bytes used by the persisted ban lists (DIAG) Number of bytes used by the persisted ban lists. bans_persisted_fragmentation Extra bytes in persisted ban lists due to fragmentation (DIAG) Number of extra bytes accumulated through dropped and completed bans in the persistent ban lists. n_purges Number of purge operations executed (INFO) n_obj_purged Number of purged objects (INFO) exp_mailed Number of objects mailed to expiry thread (DIAG) Number of objects mailed to expiry thread for handling. exp_received Number of objects received by expiry thread (DIAG) Number of objects received by expiry thread for handling. hcb_nolock HCB Lookups without lock (DEBUG) hcb_lock HCB Lookups with lock (DEBUG) hcb_insert HCB Inserts (DEBUG) esi_errors ESI parse errors (unlock) (DIAG) esi_warnings ESI parse warnings (unlock) (DIAG) vmods Loaded VMODs (INFO) n_gzip Gzip operations (INFO) n_gunzip Gunzip operations (INFO) vsm_free Free VSM space (DIAG) Number of bytes free in the shared memory used to communicate with tools like varnishstat, varnishlog etc. vsm_used Used VSM space (DIAG) Number of bytes used in the shared memory used to communicate with tools like varnishstat, varnishlog etc. vsm_cooling Cooling VSM space (DEBUG) Number of bytes which will soon (max 1 minute) be freed in the shared memory used to communicate with tools like varnishstat, varnishlog etc. vsm_cooling Cooling VSM space (DEBUG) Number of bytes which will soon (max 1 minute) be freed in the shared memory used to communicate with tools like varnishstat, varnishlog etc. vsm_overflow Overflow VSM space (DIAG) Number of bytes which does not fit in the shared memory used to communicate with tools like varnishstat, varnishlog etc. vsm_overflowed Overflowed VSM space (DIAG) Total number of bytes which did not fit in the shared memory used to communicate with tools like varnishstat, varnishlog etc. Lock Counters creat Created locks (DEBUG) destroy Destroyed locks (DEBUG) locks Lock Operations (DEBUG) Per Malloc Storage Counters c_req Allocator requests (INFO) c_fail Allocator failures (INFO) c_bytes bytes allocated (INFO) c_freed Bytes freed (INFO) g_alloc Allocations outstanding (INFO) g_bytes Bytes outstanding (INFO) g_space Bytes available (INFO) Per File Storage Counters c_req Allocator requests (INFO) c_fail Allocator failures (INFO) c_bytes Bytes allocated (INFO) c_freed Bytes freed (INFO) g_alloc Allocations outstanding (INFO) g_bytes Bytes outstanding (INFO) g_space Bytes available (INFO) g_smf N struct smf (INFO) g_smf_frag N small free smf (INFO) g_smf_large N large free smf (INFO) Per Backend Counters vcls VCL references (DEBUG) happy Happy health probes (INFO) bereq_hdrbytes Request header bytes (INFO) Total backend request header bytes sent bereq_bodybytes Request body bytes (INFO) Total backend request body bytes sent beresp_hdrbytes Response header bytes (INFO) Total backend response header bytes received beresp_bodybytes Response body bytes (INFO) Total backend response body bytes received pipe_hdrbytes Pipe request header bytes (INFO) Total request bytes sent for piped sessions pipe_out Piped bytes to backend (INFO) Total number of bytes forwarded to backend in pipe sessions pipe_in Piped bytes from backend (INFO) Total number of bytes forwarded from backend in pipe sessions [Mankier]: https://www.mankier.com/7/varnish-counters)","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/module-integrations/varnish/varnish-metrics/","objectID":"3a77e6967f96b878721150208b007261_1","order":1,"tags":null,"title":"View Varnish Cache Metrics"},{"content":"Overview Section\u0026rsquo;s platform runs on a multitude of hosting providers which means we do not provide a static set of IP addresses. This can be a problem if you wish to whitelist Section traffic to your origin infrastructure. Alternative method If you wish to whitelist our servers we suggest using a shared secret key header that is send by Section\u0026rsquo;s platform as part of all requests to the origin, and the origin can choose to block requests that do not have that header present. The best way to achieve this is with HTTP Basic Authentication. You can also use a secret key header like so (E.g. in VCL):","date":"0001-01-01T00:00:00Z","href":"https://www.section.io/docs/how-tos/application-edge-management/account-configuration/whitelist-section-traffic-on-origin/","objectID":"be330fc7730f3f7e47d3f328966f755d_0","order":0,"tags":null,"title":"Whitelist Section traffic to origin infrastructure"}]